{"version":3,"file":"ngx-hm-carousel.umd.min.js","sources":["../../../node_modules/src/util/errorObject.ts","../../../node_modules/src/util/tryCatch.ts","../../../node_modules/src/util/isFunction.ts","../../../node_modules/src/util/isArray.ts","../../../node_modules/src/util/isObject.ts","../../../node_modules/src/util/UnsubscriptionError.ts","../../../node_modules/src/Subscription.ts","../../../node_modules/src/Observer.ts","../../../node_modules/src/util/root.ts","../../../node_modules/src/symbol/rxSubscriber.ts","../../../node_modules/src/Subscriber.ts","../../../node_modules/src/OuterSubscriber.ts","../../../node_modules/src/util/isArrayLike.ts","../../../node_modules/src/util/isPromise.ts","../../../node_modules/src/util/toSubscriber.ts","../../../node_modules/src/symbol/observable.ts","../../../node_modules/src/util/noop.ts","../../../node_modules/src/util/pipe.ts","../../../node_modules/src/Observable.ts","../../../node_modules/src/symbol/iterator.ts","../../../node_modules/src/InnerSubscriber.ts","../../../node_modules/src/util/subscribeToResult.ts","../../../node_modules/src/operators/audit.ts","../../../node_modules/src/scheduler/Action.ts","../../../node_modules/src/scheduler/AsyncAction.ts","../../../node_modules/src/Scheduler.ts","../../../node_modules/src/scheduler/AsyncScheduler.ts","../../../node_modules/src/scheduler/async.ts","../../../node_modules/src/util/isNumeric.ts","../../../node_modules/src/util/isScheduler.ts","../../../node_modules/src/util/isDate.ts","../../../node_modules/src/observable/TimerObservable.ts","../../../node_modules/src/operators/buffer.ts","../../../node_modules/src/operators/bufferCount.ts","../../../node_modules/src/operators/bufferTime.ts","../../../node_modules/src/operators/bufferToggle.ts","../../../node_modules/src/operators/bufferWhen.ts","../../../node_modules/src/operators/catchError.ts","../../../node_modules/src/observable/ScalarObservable.ts","../../../node_modules/src/observable/EmptyObservable.ts","../../../node_modules/src/observable/ArrayObservable.ts","../../../node_modules/src/operators/combineLatest.ts","../../../node_modules/src/observable/PromiseObservable.ts","../../../node_modules/src/observable/IteratorObservable.ts","../../../node_modules/src/observable/ArrayLikeObservable.ts","../../../node_modules/src/Notification.ts","../../../node_modules/src/operators/observeOn.ts","../../../node_modules/src/observable/FromObservable.ts","../../../node_modules/src/operators/mergeMap.ts","../../../node_modules/src/util/identity.ts","../../../node_modules/src/operators/mergeAll.ts","../../../node_modules/src/operators/count.ts","../../../node_modules/src/operators/debounce.ts","../../../node_modules/src/operators/debounceTime.ts","../../../node_modules/src/operators/defaultIfEmpty.ts","../../../node_modules/src/operators/delay.ts","../../../node_modules/src/operators/delayWhen.ts","../../../node_modules/src/operators/dematerialize.ts","../../../node_modules/src/util/Set.ts","../../../node_modules/src/operators/distinct.ts","../../../node_modules/src/operators/distinctUntilChanged.ts","../../../node_modules/src/util/ArgumentOutOfRangeError.ts","../../../node_modules/src/operators/elementAt.ts","../../../node_modules/src/operators/every.ts","../../../node_modules/src/operators/exhaust.ts","../../../node_modules/src/operators/exhaustMap.ts","../../../node_modules/src/operators/expand.ts","../../../node_modules/src/operators/filter.ts","../../../node_modules/src/operators/finalize.ts","../../../node_modules/src/operators/find.ts","../../../node_modules/src/util/EmptyError.ts","../../../node_modules/src/operators/first.ts","../../../node_modules/src/util/ObjectUnsubscribedError.ts","../../../node_modules/src/SubjectSubscription.ts","../../../node_modules/src/Subject.ts","../../../node_modules/src/util/MapPolyfill.ts","../../../node_modules/src/util/Map.ts","../../../node_modules/src/util/FastMap.ts","../../../node_modules/src/operators/groupBy.ts","../../../node_modules/src/operators/ignoreElements.ts","../../../node_modules/src/operators/isEmpty.ts","../../../node_modules/src/operators/last.ts","../../../node_modules/src/operators/map.ts","../../../node_modules/src/operators/mapTo.ts","../../../node_modules/src/operators/materialize.ts","../../../node_modules/src/operators/scan.ts","../../../node_modules/src/operators/takeLast.ts","../../../node_modules/src/observable/merge.ts","../../../node_modules/src/operators/merge.ts","../../../node_modules/src/operators/mergeMapTo.ts","../../../node_modules/src/operators/mergeScan.ts","../../../node_modules/src/operators/refCount.ts","../../../node_modules/src/observable/ConnectableObservable.ts","../../../node_modules/src/operators/onErrorResumeNext.ts","../../../node_modules/src/operators/pairwise.ts","../../../node_modules/src/BehaviorSubject.ts","../../../node_modules/src/AsyncSubject.ts","../../../node_modules/src/scheduler/QueueAction.ts","../../../node_modules/src/scheduler/queue.ts","../../../node_modules/src/scheduler/QueueScheduler.ts","../../../node_modules/src/ReplaySubject.ts","../../../node_modules/src/observable/race.ts","../../../node_modules/src/operators/repeat.ts","../../../node_modules/src/operators/repeatWhen.ts","../../../node_modules/src/operators/retry.ts","../../../node_modules/src/operators/retryWhen.ts","../../../node_modules/src/operators/sample.ts","../../../node_modules/src/operators/sampleTime.ts","../../../node_modules/src/operators/sequenceEqual.ts","../../../node_modules/src/operators/single.ts","../../../node_modules/src/operators/skip.ts","../../../node_modules/src/operators/skipLast.ts","../../../node_modules/src/operators/skipUntil.ts","../../../node_modules/src/operators/skipWhile.ts","../../../node_modules/src/operators/switchMap.ts","../../../node_modules/src/operators/switchMapTo.ts","../../../node_modules/src/operators/take.ts","../../../node_modules/src/operators/takeUntil.ts","../../../node_modules/src/operators/takeWhile.ts","../../../node_modules/src/operators/tap.ts","../../../node_modules/src/operators/throttle.ts","../../../node_modules/src/operators/throttleTime.ts","../../../node_modules/src/operators/timeInterval.ts","../../../node_modules/src/util/TimeoutError.ts","../../../node_modules/src/operators/timeout.ts","../../../node_modules/src/operators/timeoutWith.ts","../../../node_modules/src/operators/window.ts","../../../node_modules/src/operators/windowCount.ts","../../../node_modules/src/operators/windowTime.ts","../../../node_modules/src/operators/windowToggle.ts","../../../node_modules/src/operators/windowWhen.ts","../../../node_modules/src/operators/withLatestFrom.ts","../../../node_modules/src/operators/zip.ts","../../../node_modules/src/operators.ts","~/ngx-hm-carousel/src/lib/src/ngx-hm-carousel-item.directive.ts","~/ngx-hm-carousel/src/lib/src/only-on.browser.ts","~/ngx-hm-carousel/src/lib/src/ngx-hm-carousel.component.ts","~/ngx-hm-carousel/src/lib/src/ngx-hm-carousel.module.ts"],"sourcesContent":["// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');","export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index: number = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, private outerValue: T, private outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscription, TeardownLogic } from '../Subscription';\n\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private value: T;\n  private hasValue: boolean = false;\n  private throttled: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      const duration = tryCatch(this.durationSelector)(value);\n      if (duration === errorObject) {\n        this.destination.error(errorObject.e);\n      } else {\n        const innerSubscription = subscribeToResult(this, duration);\n        if (innerSubscription.closed) {\n          this.clearThrottle();\n        } else {\n          this.add(this.throttled = innerSubscription);\n        }\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: Action<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  protected _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\n\nexport interface IScheduler {\n  now(): number;\n  schedule<T>(work: (this: Action<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nexport class Scheduler implements IScheduler {\n\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: Action<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { isArray } from '../util/isArray';\n\nexport function isNumeric(val: any): val is number {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n};\n","import { Scheduler } from '../Scheduler';\nexport function isScheduler(value: any): value is Scheduler {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","export function isDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(+value);\n}\n","import { isNumeric } from '../util/isNumeric';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isDate } from '../util/isDate';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class TimerObservable extends Observable<number> {\n\n  /**\n   * Creates an Observable that starts emitting after an `initialDelay` and\n   * emits ever increasing numbers after each `period` of time thereafter.\n   *\n   * <span class=\"informal\">Its like {@link interval}, but you can specify when\n   * should the emissions start.</span>\n   *\n   * <img src=\"./img/timer.png\" width=\"100%\">\n   *\n   * `timer` returns an Observable that emits an infinite sequence of ascending\n   * integers, with a constant interval of time, `period` of your choosing\n   * between those emissions. The first emission happens after the specified\n   * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n   * operator uses the `async` IScheduler to provide a notion of time, but you\n   * may pass any IScheduler to it. If `period` is not specified, the output\n   * Observable emits only one value, `0`. Otherwise, it emits an infinite\n   * sequence.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n   * var numbers = Rx.Observable.timer(3000, 1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @example <caption>Emits one number after five seconds</caption>\n   * var numbers = Rx.Observable.timer(5000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link interval}\n   * @see {@link delay}\n   *\n   * @param {number|Date} initialDelay The initial delay time to wait before\n   * emitting the first value of `0`.\n   * @param {number} [period] The period of time between emissions of the\n   * subsequent numbers.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a `0` after the\n   * `initialDelay` and ever increasing numbers after each `period` of time\n   * thereafter.\n   * @static true\n   * @name timer\n   * @owner Observable\n   */\n  static create(initialDelay: number | Date = 0,\n                period?: number | IScheduler,\n                scheduler?: IScheduler): Observable<number> {\n    return new TimerObservable(initialDelay, period, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, period, subscriber } = state;\n    const action = (<any> this);\n\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    } else if (period === -1) {\n      return subscriber.complete();\n    }\n\n    state.index = index + 1;\n    action.schedule(state, period);\n  }\n\n  private period: number = -1;\n  private dueTime: number = 0;\n  private scheduler: IScheduler;\n\n  constructor(dueTime: number | Date = 0,\n              period?: number | IScheduler,\n              scheduler?: IScheduler) {\n    super();\n\n    if (isNumeric(period)) {\n      this.period = Number(period) < 1 && 1 || Number(period);\n    } else if (isScheduler(period)) {\n      scheduler = <IScheduler> period;\n    }\n\n    if (!isScheduler(scheduler)) {\n      scheduler = async;\n    }\n\n    this.scheduler = scheduler;\n    this.dueTime = isDate(dueTime) ?\n      (+dueTime - this.scheduler.now()) :\n      (<number> dueTime);\n  }\n\n  protected _subscribe(subscriber: Subscriber<number>): TeardownLogic {\n    const index = 0;\n    const { period, dueTime, scheduler } = this;\n\n    return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n      index, period, subscriber\n    });\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> {\n  return function bufferOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferOperator<T>(closingNotifier));\n  };\n}\n\nclass BufferOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingNotifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSubscriber<T> extends OuterSubscriber<T, any> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, closingNotifier));\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    const buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number = null): OperatorFunction<T, T[]> {\n  return function bufferCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferCountOperator<T>(bufferSize, startBufferEvery));\n  };\n}\n\nclass BufferCountOperator<T> implements Operator<T, T[]> {\n  private subscriberClass: any;\n\n  constructor(private bufferSize: number, private startBufferEvery: number) {\n    if (!startBufferEvery || bufferSize === startBufferEvery) {\n      this.subscriberClass = BufferCountSubscriber;\n    } else {\n      this.subscriberClass = BufferSkipCountSubscriber;\n    }\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): TeardownLogic {\n    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferCountSubscriber<T> extends Subscriber<T> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const buffer = this.buffer;\n\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  }\n\n  protected _complete(): void {\n    const buffer = this.buffer;\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSkipCountSubscriber<T> extends Subscriber<T> {\n  private buffers: Array<T[]> = [];\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number, private startBufferEvery: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const { bufferSize, startBufferEvery, buffers, count } = this;\n\n    this.count++;\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (let i = buffers.length; i--; ) {\n      const buffer = buffers[i];\n      buffer.push(value);\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  }\n\n  protected _complete(): void {\n    const { buffers, destination } = this;\n\n    while (buffers.length > 0) {\n      let buffer = buffers.shift();\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n    super._complete();\n  }\n\n}\n","import { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, maxBufferSize: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: IScheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ntype CreationState<T> = {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number,\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: IScheduler;\n};\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: CreationState<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  protected _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: Action<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\nfunction dispatchBufferCreation<T>(this: Action<CreationState<T>>, state: CreationState<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <Action<CreationState<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle<T, O>(\n  openings: SubscribableOrPromise<O>,\n  closingSelector: (value: O) => SubscribableOrPromise<any>\n): OperatorFunction<T, T[]> {\n  return function bufferToggleOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));\n  };\n}\n\nclass BufferToggleOperator<T, O> implements Operator<T, T[]> {\n\n  constructor(private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  }\n}\n\ninterface BufferContext<T> {\n  buffer: T[];\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> {\n  private contexts: Array<BufferContext<T>> = [];\n\n  constructor(destination: Subscriber<T[]>,\n              private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) {\n    super(destination);\n    this.add(subscribeToResult(this, openings));\n  }\n\n  protected _next(value: T): void {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    for (let i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._error(err);\n  }\n\n  protected _complete(): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      this.destination.next(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._complete();\n  }\n\n  notifyNext(outerValue: any, innerValue: O,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, O>): void {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, O>): void {\n    this.closeBuffer((<any> innerSub).context);\n  }\n\n  private openBuffer(value: O): void {\n    try {\n      const closingSelector = this.closingSelector;\n      const closingNotifier = closingSelector.call(this, value);\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private closeBuffer(context: BufferContext<T>): void {\n    const contexts = this.contexts;\n\n    if (contexts && context) {\n      const { buffer, subscription } = context;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  }\n\n  private trySubscribe(closingNotifier: any): void {\n    const contexts = this.contexts;\n\n    const buffer: Array<T> = [];\n    const subscription = new Subscription();\n    const context = { buffer, subscription };\n    contexts.push(context);\n\n    const innerSubscription = subscribeToResult(this, closingNotifier, <any>context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      (<any> innerSubscription).context = context;\n\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]> {\n  return function (source: Observable<T>) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nclass BufferWhenOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferWhenSubscriber<T> extends OuterSubscriber<T, any> {\n  private buffer: T[];\n  private subscribing: boolean = false;\n  private closingSubscription: Subscription;\n\n  constructor(destination: Subscriber<T[]>, private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openBuffer();\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  protected _complete() {\n    const buffer = this.buffer;\n    if (buffer) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n\n  protected _unsubscribe() {\n    this.buffer = null;\n    this.subscribing = false;\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openBuffer();\n  }\n\n  notifyComplete(): void {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  }\n\n  openBuffer() {\n\n    let { closingSubscription } = this;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    const buffer = this.buffer;\n    if (this.buffer) {\n      this.destination.next(buffer);\n    }\n\n    this.buffer = [];\n\n    const closingNotifier = tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject) {\n      this.error(errorObject.e);\n    } else {\n      closingSubscription = new Subscription();\n      this.closingSubscription = closingSubscription;\n      this.add(closingSubscription);\n      this.subscribing = true;\n      closingSubscription.add(subscribeToResult(this, closingNotifier));\n      this.subscribing = false;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R> {\n  return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | R> {\n    const operator = new CatchOperator(selector);\n    const caught = source.lift(operator);\n    return (operator.caught = caught as Observable<T>);\n  };\n}\n\nclass CatchOperator<T, R> implements Operator<T, T | R> {\n  caught: Observable<T>;\n\n  constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CatchSubscriber<T, R> extends OuterSubscriber<T, T | R> {\n  constructor(destination: Subscriber<any>,\n              private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>,\n              private caught: Observable<T>) {\n    super(destination);\n  }\n\n  // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n  error(err: any) {\n    if (!this.isStopped) {\n      let result: any;\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        super.error(err2);\n        return;\n      }\n      this._unsubscribeAndRecycle();\n      this.add(subscribeToResult(this, result));\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nexport interface DispatchArg<T> {\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class EmptyObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n  static create<T>(scheduler?: IScheduler): Observable<T> {\n    return new EmptyObservable<T>(scheduler);\n  }\n\n  static dispatch<T>(arg: DispatchArg<T>) {\n    const { subscriber } = arg;\n    subscriber.complete();\n  }\n\n  constructor(private scheduler?: IScheduler) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber });\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(new ArrayObservable([source, ...observables]), new CombineLatestOperator(project));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private project?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private project?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(none);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryProject(values: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class IteratorObservable<T> extends Observable<T> {\n  private iterator: any;\n\n  static create<T>(iterator: any, scheduler?: IScheduler): IteratorObservable<T> {\n    return new IteratorObservable(iterator, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, hasError, iterator, subscriber } = state;\n\n    if (hasError) {\n      subscriber.error(state.error);\n      return;\n    }\n\n    let result = iterator.next();\n    if (result.done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(result.value);\n    state.index = index + 1;\n\n    if (subscriber.closed) {\n      if (typeof iterator.return === 'function') {\n        iterator.return();\n      }\n      return;\n    }\n\n    (<any> this).schedule(state);\n  }\n\n  constructor(iterator: any, private scheduler?: IScheduler) {\n    super();\n\n    if (iterator == null) {\n      throw new Error('iterator cannot be null.');\n    }\n\n    this.iterator = getIterator(iterator);\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    let index = 0;\n    const { iterator, scheduler } = this;\n\n    if (scheduler) {\n      return scheduler.schedule(IteratorObservable.dispatch, 0, {\n        index, iterator, subscriber\n      });\n    } else {\n      do {\n        let result = iterator.next();\n        if (result.done) {\n          subscriber.complete();\n          break;\n        } else {\n          subscriber.next(result.value);\n        }\n        if (subscriber.closed) {\n          if (typeof iterator.return === 'function') {\n            iterator.return();\n          }\n          break;\n        }\n      } while (true);\n    }\n  }\n}\n\nclass StringIterator {\n  constructor(private str: string,\n              private idx: number = 0,\n              private len: number = str.length) {\n  }\n  [Symbol_iterator]() { return (this); }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.str.charAt(this.idx++)\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nclass ArrayIterator {\n  constructor(private arr: Array<any>,\n              private idx: number = 0,\n              private len: number = toLength(arr)) {\n  }\n  [Symbol_iterator]() { return this; }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.arr[this.idx++]\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nfunction getIterator(obj: any) {\n  const i = obj[Symbol_iterator];\n  if (!i && typeof obj === 'string') {\n    return new StringIterator(obj);\n  }\n  if (!i && obj.length !== undefined) {\n    return new ArrayIterator(obj);\n  }\n  if (!i) {\n    throw new TypeError('object is not iterable');\n  }\n  return obj[Symbol_iterator]();\n}\n\nconst maxSafeInteger = Math.pow(2, 53) - 1;\n\nfunction toLength(o: any) {\n  let len = +o.length;\n  if (isNaN(len)) {\n      return 0;\n  }\n  if (len === 0 || !numberIsFinite(len)) {\n      return len;\n  }\n  len = sign(len) * Math.floor(Math.abs(len));\n  if (len <= 0) {\n      return 0;\n  }\n  if (len > maxSafeInteger) {\n      return maxSafeInteger;\n  }\n  return len;\n}\n\nfunction numberIsFinite(value: any) {\n  return typeof value === 'number' && root.isFinite(value);\n}\n\nfunction sign(value: any) {\n  let valueAsNumber = +value;\n  if (valueAsNumber === 0) {\n    return valueAsNumber;\n  }\n  if (isNaN(valueAsNumber)) {\n    return valueAsNumber;\n  }\n  return valueAsNumber < 0 ? -1 : 1;\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayLikeObservable<T> extends Observable<T> {\n\n  static create<T>(arrayLike: ArrayLike<T>, scheduler?: IScheduler): Observable<T> {\n    const length = arrayLike.length;\n    if (length === 0) {\n      return new EmptyObservable<T>();\n    } else if (length === 1) {\n      return new ScalarObservable<T>(<any>arrayLike[0], scheduler);\n    } else {\n      return new ArrayLikeObservable(arrayLike, scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n    const { arrayLike, index, length, subscriber } = state;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (index >= length) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(arrayLike[index]);\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  private value: any;\n\n  constructor(private arrayLike: ArrayLike<T>, private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && arrayLike.length === 1) {\n      this._isScalar = true;\n      this.value = arrayLike[0];\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const { arrayLike, scheduler } = this;\n    const length = arrayLike.length;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n        arrayLike, index, length, subscriber\n      });\n    } else {\n      for (let i = 0; i < length && !subscriber.closed; i++) {\n        subscriber.next(arrayLike[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { PartialObserver } from './Observer';\nimport { Observable } from './Observable';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return Observable.of(this.value);\n      case 'E':\n        return Observable.throw(this.error);\n      case 'C':\n        return Observable.empty<T>();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { TeardownLogic } from '../Subscription';\nimport { Action } from '../scheduler/Action';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: IScheduler, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: IScheduler, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  static dispatch(this: Action<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: IScheduler,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","import { isArray } from '../util/isArray';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { PromiseObservable } from './PromiseObservable';\nimport { IteratorObservable } from'./IteratorObservable';\nimport { ArrayObservable } from './ArrayObservable';\nimport { ArrayLikeObservable } from './ArrayLikeObservable';\n\nimport { IScheduler } from '../Scheduler';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObserveOnSubscriber } from '../operators/observeOn';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromObservable<T> extends Observable<T> {\n  constructor(private ish: ObservableInput<T>, private scheduler?: IScheduler) {\n    super(null);\n  }\n\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\n  static create<T, R>(ish: ArrayLike<T>, scheduler?: IScheduler): Observable<R>;\n\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T> {\n    if (ish != null) {\n      if (typeof ish[Symbol_observable] === 'function') {\n        if (ish instanceof Observable && !scheduler) {\n          return ish;\n        }\n        return new FromObservable<T>(ish, scheduler);\n      } else if (isArray(ish)) {\n        return new ArrayObservable<T>(ish, scheduler);\n      } else if (isPromise<T>(ish)) {\n        return new PromiseObservable<T>(ish, scheduler);\n      } else if (typeof ish[Symbol_iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable<T>(ish, scheduler);\n      } else if (isArrayLike(ish)) {\n        return new ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    const ish = this.ish;\n    const scheduler = this.scheduler;\n    if (scheduler == null) {\n      return ish[Symbol_observable]().subscribe(subscriber);\n    } else {\n      return ish[Symbol_observable]().subscribe(new ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>,\n                                  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                  concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, I|R> {\n  return function mergeMapOperatorFunction(source: Observable<T>) {\n    if (typeof resultSelector === 'number') {\n      concurrent = <number>resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, <any>resultSelector, concurrent));\n  };\n}\n\nexport class MergeMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<I>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.resultSelector, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<I>, value: T, index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","export function identity<T>(x: T): T {\n  return x;\n}\n","\nimport { ObservableInput } from '../Observable';\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): MonoTypeOperatorFunction<T> {\n  return mergeMap(identity as (value: T, index: number) => ObservableInput<{}>, null, concurrent);\n}","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Observer } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nexport function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new CountOperator(predicate, source));\n}\n\nclass CountOperator<T> implements Operator<T, number> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<number>, source: any): any {\n    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CountSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n  private index: number = 0;\n\n  constructor(destination: Observer<number>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  }\n\n  private _tryPredicate(value: T) {\n    let result: any;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  }\n\n  protected _complete(): void {\n    this.destination.next(this.count);\n    this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<number>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceOperator(durationSelector));\n}\n\nclass DebounceOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<number>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private value: T;\n  private hasValue: boolean = false;\n  private durationSubscription: Subscription = null;\n\n  constructor(destination: Subscriber<R>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    try {\n      const result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.emitValue();\n    this.destination.complete();\n  }\n\n  private _tryNext(value: T, duration: SubscribableOrPromise<number>): void {\n    let subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = subscribeToResult(this, duration);\n    if (!subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue(): void {\n    if (this.hasValue) {\n      const value = this.value;\n      const subscription = this.durationSubscription;\n      if (subscription) {\n        this.durationSubscription = null;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n      this.value = null;\n      this.hasValue = false;\n      super._next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: IScheduler) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      this.destination.next(this.lastValue);\n      this.lastValue = null;\n      this.hasValue = false;\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R = null): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new DefaultIfEmptyOperator(defaultValue)) as Observable<T | R>;\n}\n\nclass DefaultIfEmptyOperator<T, R> implements Operator<T, T | R> {\n\n  constructor(private defaultValue: R) {\n  }\n\n  call(subscriber: Subscriber<T | R>, source: any): any {\n    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DefaultIfEmptySubscriber<T, R> extends Subscriber<T> {\n  private isEmpty: boolean = true;\n\n  constructor(destination: Subscriber<T | R>, private defaultValue: R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.isEmpty = false;\n    this.destination.next(value);\n  }\n\n  protected _complete(): void {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n    this.destination.complete();\n  }\n}","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Action } from '../scheduler/Action';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { PartialObserver } from '../Observer';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: IScheduler;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: Action<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: IScheduler) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: IScheduler): void {\n    this.active = true;\n    this.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nexport function delayWhen<T>(delayDurationSelector: (value: T) => Observable<any>,\n                             subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    return (source: Observable<T>) =>\n      new SubscriptionDelayObservable(source, subscriptionDelay)\n        .lift(new DelayWhenOperator(delayDurationSelector));\n  }\n  return (source: Observable<T>) => source.lift(new DelayWhenOperator(delayDurationSelector));\n}\n\nclass DelayWhenOperator<T> implements Operator<T, T> {\n  constructor(private delayDurationSelector: (value: T) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelayWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private completed: boolean = false;\n  private delayNotifierSubscriptions: Array<Subscription> = [];\n  private values: Array<T> = [];\n\n  constructor(destination: Subscriber<T>,\n              private delayDurationSelector: (value: T) => Observable<any>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    const value = this.removeSubscription(innerSub);\n    if (value) {\n      this.destination.next(value);\n    }\n    this.tryComplete();\n  }\n\n  protected _next(value: T): void {\n    try {\n      const delayNotifier = this.delayDurationSelector(value);\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.completed = true;\n    this.tryComplete();\n  }\n\n  private removeSubscription(subscription: InnerSubscriber<T, R>): T {\n    subscription.unsubscribe();\n\n    const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n    let value: T = null;\n\n    if (subscriptionIdx !== -1) {\n      value = this.values[subscriptionIdx];\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n      this.values.splice(subscriptionIdx, 1);\n    }\n\n    return value;\n  }\n\n  private tryDelay(delayNotifier: Observable<any>, value: T): void {\n    const notifierSubscription = subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      this.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n\n    this.values.push(value);\n  }\n\n  private tryComplete(): void {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete();\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelayObservable<T> extends Observable<T> {\n  constructor(protected source: Observable<T>, private subscriptionDelay: Observable<any>) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelaySubscriber<T> extends Subscriber<T> {\n  private sourceSubscribed: boolean = false;\n\n  constructor(private parent: Subscriber<T>, private source: Observable<T>) {\n    super();\n  }\n\n  protected _next(unused: any) {\n    this.subscribeToSource();\n  }\n\n  protected _error(err: any) {\n    this.unsubscribe();\n    this.parent.error(err);\n  }\n\n  protected _complete() {\n    this.subscribeToSource();\n  }\n\n  private subscribeToSource(): void {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport function dematerialize<T>(): OperatorFunction<Notification<T>, T> {\n  return function dematerializeOperatorFunction(source: Observable<Notification<T>>) {\n    return source.lift(new DeMaterializeOperator());\n  };\n}\n\nclass DeMaterializeOperator<T extends Notification<any>, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<any>, source: any): any {\n    return source.subscribe(new DeMaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DeMaterializeSubscriber<T extends Notification<any>> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    value.observe(this.destination);\n  }\n}\n","import { root } from './root';\n\nexport interface ISetCtor {\n  new<T>(): ISet<T>;\n}\n\nexport interface ISet<T> {\n  add(value: T): void;\n  has(value: T): boolean;\n  size: number;\n  clear(): void;\n}\n\nexport function minimalSetImpl<T>(): ISetCtor {\n  // THIS IS NOT a full impl of Set, this is just the minimum\n  // bits of functionality we need for this library.\n  return class MinimalSet<T> implements ISet<T> {\n    private _values: T[] = [];\n\n    add(value: T): void {\n      if (!this.has(value)) {\n        this._values.push(value);\n      }\n    }\n\n    has(value: T): boolean {\n      return this._values.indexOf(value) !== -1;\n    }\n\n    get size(): number {\n      return this._values.length;\n    }\n\n    clear(): void {\n      this._values.length = 0;\n    }\n  };\n}\n\nexport const Set: ISetCtor = root.Set || minimalSetImpl();","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ISet, Set } from '../util/Set';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K,\n                               flushes?: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctOperator(keySelector, flushes));\n}\n\nclass DistinctOperator<T, K> implements Operator<T, T> {\n  constructor(private keySelector: (value: T) => K, private flushes: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class DistinctSubscriber<T, K> extends OuterSubscriber<T, T> {\n  private values: ISet<K> = new Set<K>();\n\n  constructor(destination: Subscriber<T>, private keySelector: (value: T) => K, flushes: Observable<any>) {\n    super(destination);\n\n    if (flushes) {\n      this.add(subscribeToResult(this, flushes));\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    this.values.clear();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, T>): void {\n    this._error(error);\n  }\n\n  protected _next(value: T): void {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  }\n\n  private _useKeySelector(value: T): void {\n    let key: K;\n    const { destination } = this;\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this._finalizeNext(key, value);\n  }\n\n  private _finalizeNext(key: K|T, value: T) {\n    const { values } = this;\n    if (!values.has(<K>key)) {\n      values.add(<K>key);\n      this.destination.next(value);\n    }\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));\n}\n\nclass DistinctUntilChangedOperator<T, K> implements Operator<T, T> {\n  constructor(private compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> {\n  private key: K;\n  private hasKey: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n    super(destination);\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  private compare(x: any, y: any): boolean {\n    return x === y;\n  }\n\n  protected _next(value: T): void {\n\n    const keySelector = this.keySelector;\n    let key: any = value;\n\n    if (keySelector) {\n      key = tryCatch(this.keySelector)(value);\n      if (key === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    }\n\n    let result: any = false;\n\n    if (this.hasKey) {\n      result = tryCatch(this.compare)(this.key, key);\n      if (result === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    } else {\n      this.hasKey = true;\n    }\n\n    if (Boolean(result) === false) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  }\n}\n","/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport class ArgumentOutOfRangeError extends Error {\n  constructor() {\n    const err: any = super('argument out of range');\n    (<any> this).name = err.name = 'ArgumentOutOfRangeError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nexport function elementAt<T>(index: number, defaultValue?: T): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ElementAtOperator(index, defaultValue));\n}\n\nclass ElementAtOperator<T> implements Operator<T, T> {\n\n  constructor(private index: number, private defaultValue?: T) {\n    if (index < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ElementAtSubscriber<T> extends Subscriber<T> {\n\n  constructor(destination: Subscriber<T>, private index: number, private defaultValue?: T) {\n    super(destination);\n  }\n\n  protected _next(x: T) {\n    if (this.index-- === 0) {\n      this.destination.next(x);\n      this.destination.complete();\n    }\n  }\n\n  protected _complete() {\n    const destination = this.destination;\n    if (this.index >= 0) {\n      if (typeof this.defaultValue !== 'undefined') {\n        destination.next(this.defaultValue);\n      } else {\n        destination.error(new ArgumentOutOfRangeError);\n      }\n    }\n    destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observer } from '../Observer';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         thisArg?: any): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new EveryOperator(predicate, thisArg, source));\n}\n\nclass EveryOperator<T> implements Operator<T, boolean> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass EverySubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Observer<boolean>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg: any,\n              private source?: Observable<T>) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  private notifyComplete(everyValueMatch: boolean): void {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  }\n\n  protected _next(value: T): void {\n    let result = false;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nexport function exhaust<T>(): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\n}\n\nclass SwitchFirstOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstSubscriber<T> extends OuterSubscriber<T, T> {\n  private hasCompleted: boolean = false;\n  private hasSubscription: boolean = false;\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, value));\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n  ): OperatorFunction<T, R> {\n    return (source: Observable<T>) => source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  }\n\nclass SwitchFirstMapOperator<T, I, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasSubscription: boolean = false;\n  private hasCompleted: boolean = false;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    const index = this.index++;\n    const destination = this.destination;\n    try {\n      const result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private trySelectResult(outerValue: T, innerValue: I,\n                          outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    try {\n      const result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function expand<T>(project: (value: T, index: number) => Observable<T>, concurrent?: number, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function expand<T, R>(project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand<T, R>(project: (value: T, index: number) => Observable<R>,\n                             concurrent: number = Number.POSITIVE_INFINITY,\n                             scheduler: IScheduler = undefined): OperatorFunction<T, R> {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\n  return (source: Observable<T>) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\n\nexport class ExpandOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => Observable<R>,\n              private concurrent: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n}\n\ninterface DispatchArg<T, R> {\n  subscriber: ExpandSubscriber<T, R>;\n  result: Observable<R>;\n  value: any;\n  index: number;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private index: number = 0;\n  private active: number = 0;\n  private hasCompleted: boolean = false;\n  private buffer: any[];\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => Observable<R>,\n              private concurrent: number,\n              private scheduler: IScheduler) {\n    super(destination);\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  private static dispatch<T, R>(arg: DispatchArg<T, R>): void {\n    const {subscriber, result, value, index} = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  protected _next(value: any): void {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n      return;\n    }\n\n    const index = this.index++;\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      let result = tryCatch(this.project)(value, index);\n      if (result === errorObject) {\n        destination.error(errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        const state: DispatchArg<T, R> = { subscriber: this, result, value, index };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private subscribeToProjection(result: any, value: T, index: number): void {\n    this.active++;\n    this.add(subscribeToResult<T, R>(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this._next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new FinallyOperator(callback));\n}\n\nclass FinallyOperator<T> implements Operator<T, T> {\n  constructor(private callback: () => void) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FinallySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<T>, callback: () => void) {\n    super(destination);\n    this.add(new Subscription(callback));\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\nexport function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S>;\nexport function find<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T>;\nexport function find<T>(predicate: (value: T, index: number) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T> {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\n\nexport class FindValueOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n  }\n\n  call(observer: Subscriber<T>, source: any): any {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class FindValueSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n    super(destination);\n  }\n\n  private notifyComplete(value: any): void {\n    const destination = this.destination;\n\n    destination.next(value);\n    destination.complete();\n  }\n\n  protected _next(value: T): void {\n    const { predicate, thisArg } = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}\n","/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport class EmptyError extends Error {\n  constructor() {\n    const err: any = super('no elements in sequence');\n    (<any> this).name = err.name = 'EmptyError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n/* tslint:disable:max-line-length */\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S): OperatorFunction<T, S>;\nexport function first<T, S extends T, R>(predicate: (value: T | S, index: number, source: Observable<T>) => value is S,\n                                         resultSelector: (value: S, index: number) => R, defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                      resultSelector: void,\n                                      defaultValue?: S): OperatorFunction<T, S>;\nexport function first<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\nexport function first<T, R>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: (value: T, index: number) => R,\n                            defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         resultSelector: void,\n                         defaultValue?: T): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: ((value: T, index: number) => R) | void,\n                            defaultValue?: R): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source));\n}\n\nclass FirstOperator<T, R> implements Operator<T, R> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FirstSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n  private hasCompleted: boolean = false;\n  private _emitted: boolean = false;\n\n  constructor(destination: Subscriber<R>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      this._emit(value, index);\n    }\n  }\n\n  private _tryPredicate(value: T, index: number) {\n    let result: any;\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this._emit(value, index);\n    }\n  }\n\n  private _emit(value: any, index: number) {\n    if (this.resultSelector) {\n      this._tryResultSelector(value, index);\n      return;\n    }\n    this._emitFinal(value);\n  }\n\n  private _tryResultSelector(value: T, index: number) {\n    let result: any;\n    try {\n      result = (<any>this).resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this._emitFinal(result);\n  }\n\n  private _emitFinal(value: any) {\n    const destination = this.destination;\n    if (!this._emitted) {\n      this._emitted = true;\n      destination.next(value);\n      destination.complete();\n      this.hasCompleted = true;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n      destination.next(this.defaultValue);\n      destination.complete();\n    } else if (!this.hasCompleted) {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport class ObjectUnsubscribedError extends Error {\n  constructor() {\n    const err: any = super('object unsubscribed');\n    (<any> this).name = err.name = 'ObjectUnsubscribedError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './Observer';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observer } from './Observer';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { ISubscription, Subscription, TeardownLogic } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements ISubscription {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","export class MapPolyfill {\n  public size = 0;\n  private _values: any[] = [];\n  private _keys: any[] = [];\n\n  get(key: any) {\n    const i = this._keys.indexOf(key);\n    return i === -1 ? undefined : this._values[i];\n  }\n\n  set(key: any, value: any) {\n    const i = this._keys.indexOf(key);\n    if (i === -1) {\n      this._keys.push(key);\n      this._values.push(value);\n      this.size++;\n    } else {\n      this._values[i] = value;\n    }\n    return this;\n  }\n\n  delete(key: any): boolean {\n    const i = this._keys.indexOf(key);\n    if (i === -1) { return false; }\n    this._values.splice(i, 1);\n    this._keys.splice(i, 1);\n    this.size--;\n    return true;\n  }\n\n  clear(): void {\n    this._keys.length = 0;\n    this._values.length = 0;\n    this.size = 0;\n  }\n\n  forEach(cb: Function, thisArg: any): void {\n    for (let i = 0; i < this.size; i++) {\n      cb.call(thisArg, this._values[i], this._keys[i]);\n    }\n  }\n}","import { root } from './root';\nimport { MapPolyfill } from './MapPolyfill';\n\nexport const Map = root.Map || (() => MapPolyfill)();","export class FastMap {\n  private values: Object = {};\n\n  delete(key: string): boolean {\n    this.values[key] = null;\n    return true;\n  }\n\n  set(key: string, value: any): FastMap {\n    this.values[key] = value;\n    return this;\n  }\n\n  get(key: string): any {\n    return this.values[key];\n  }\n\n  forEach(cb: (value: any, key: any) => void, thisArg?: any): void {\n    const values = this.values;\n    for (let key in values) {\n      if (values.hasOwnProperty(key) && values[key] !== null) {\n        cb.call(thisArg, values[key], key);\n      }\n    }\n  }\n\n  clear(): void {\n    this.values = {};\n  }\n}","import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subject } from '../Subject';\nimport { Map } from '../util/Map';\nimport { FastMap } from '../util/FastMap';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nexport function groupBy<T, K, R>(keySelector: (value: T) => K,\n                                 elementSelector?: ((value: T) => R) | void,\n                                 durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n                                 subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>> {\n  return (source: Observable<T>) =>\n    source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\n\nexport interface RefCountSubscription {\n  count: number;\n  unsubscribe: () => void;\n  closed: boolean;\n  attemptedToUnsubscribe: boolean;\n}\n\nclass GroupByOperator<T, K, R> implements Operator<T, GroupedObservable<K, R>> {\n  constructor(private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n  }\n\n  call(subscriber: Subscriber<GroupedObservable<K, R>>, source: any): any {\n    return source.subscribe(new GroupBySubscriber(\n      subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupBySubscriber<T, K, R> extends Subscriber<T> implements RefCountSubscription {\n  private groups: Map<K, Subject<T|R>> = null;\n  public attemptedToUnsubscribe: boolean = false;\n  public count: number = 0;\n\n  constructor(destination: Subscriber<GroupedObservable<K, R>>,\n              private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    let key: K;\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      this.error(err);\n      return;\n    }\n\n    this._group(value, key);\n  }\n\n  private _group(value: T, key: K) {\n    let groups = this.groups;\n\n    if (!groups) {\n      groups = this.groups = typeof key === 'string' ? new FastMap() : new Map();\n    }\n\n    let group = groups.get(key);\n\n    let element: R;\n    if (this.elementSelector) {\n      try {\n        element = this.elementSelector(value);\n      } catch (err) {\n        this.error(err);\n      }\n    } else {\n      element = <any>value;\n    }\n\n    if (!group) {\n      group = this.subjectSelector ? this.subjectSelector() : new Subject<R>();\n      groups.set(key, group);\n      const groupedObservable = new GroupedObservable(key, group, this);\n      this.destination.next(groupedObservable);\n      if (this.durationSelector) {\n        let duration: any;\n        try {\n          duration = this.durationSelector(new GroupedObservable<K, R>(key, <Subject<R>>group));\n        } catch (err) {\n          this.error(err);\n          return;\n        }\n        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n      }\n    }\n\n    if (!group.closed) {\n      group.next(element);\n    }\n  }\n\n  protected _error(err: any): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.error(err);\n      });\n\n      groups.clear();\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.complete();\n      });\n\n      groups.clear();\n    }\n    this.destination.complete();\n  }\n\n  removeGroup(key: K): void {\n    this.groups.delete(key);\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      this.attemptedToUnsubscribe = true;\n      if (this.count === 0) {\n        super.unsubscribe();\n      }\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupDurationSubscriber<K, T> extends Subscriber<T> {\n  constructor(private key: K,\n              private group: Subject<T>,\n              private parent: GroupBySubscriber<any, K, T>) {\n    super(group);\n  }\n\n  protected _next(value: T): void {\n    this.complete();\n  }\n\n  protected _unsubscribe() {\n    const { parent, key } = this;\n    this.key = this.parent = null;\n    if (parent) {\n      parent.removeGroup(key);\n    }\n  }\n}\n\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport class GroupedObservable<K, T> extends Observable<T> {\n  constructor(public key: K,\n              private groupSubject: Subject<T>,\n              private refCountSubscription?: RefCountSubscription) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    const subscription = new Subscription();\n    const {refCountSubscription, groupSubject} = this;\n    if (refCountSubscription && !refCountSubscription.closed) {\n      subscription.add(new InnerRefCountSubscription(refCountSubscription));\n    }\n    subscription.add(groupSubject.subscribe(subscriber));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass InnerRefCountSubscription extends Subscription {\n  constructor(private parent: RefCountSubscription) {\n    super();\n    parent.count++;\n  }\n\n  unsubscribe() {\n    const parent = this.parent;\n    if (!parent.closed && !this.closed) {\n      super.unsubscribe();\n      parent.count -= 1;\n      if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n        parent.unsubscribe();\n      }\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { noop } from '../util/noop';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport function ignoreElements<T>(): MonoTypeOperatorFunction<T> {\n  return function ignoreElementsOperatorFunction(source: Observable<T>) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nclass IgnoreElementsOperator<T, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IgnoreElementsSubscriber<T> extends Subscriber<T> {\n  protected _next(unused: T): void {\n    noop();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new IsEmptyOperator());\n}\n\nclass IsEmptyOperator implements Operator<any, boolean> {\n  call (observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new IsEmptySubscriber(observer));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IsEmptySubscriber extends Subscriber<any> {\n  constructor(destination: Subscriber<boolean>) {\n    super(destination);\n  }\n\n  private notifyComplete(isEmpty: boolean): void {\n    const destination = this.destination;\n\n    destination.next(isEmpty);\n    destination.complete();\n  }\n\n  protected _next(value: boolean) {\n    this.notifyComplete(false);\n  }\n\n  protected _complete() {\n    this.notifyComplete(true);\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function last<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S): OperatorFunction<T, S>;\nexport function last<T, S extends T, R>(predicate: (value: T | S, index: number, source: Observable<T>) => value is S,\n                                        resultSelector: (value: S, index: number) => R, defaultValue?: R): OperatorFunction<T, R>;\nexport function last<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     resultSelector: void,\n                                     defaultValue?: S): OperatorFunction<T, S>;\nexport function last<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\nexport function last<T, R>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                           resultSelector?: (value: T, index: number) => R,\n                           defaultValue?: R): OperatorFunction<T, R>;\nexport function last<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        resultSelector: void,\n                        defaultValue?: T): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nexport function last<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n                           resultSelector?: ((value: T, index: number) => R) | void,\n                           defaultValue?: R): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new LastOperator(predicate, resultSelector, defaultValue, source));\n}\n\nclass LastOperator<T, R> implements Operator<T, R> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass LastSubscriber<T, R> extends Subscriber<T> {\n  private lastValue: T | R;\n  private hasValue: boolean = false;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n    super(destination);\n    if (typeof defaultValue !== 'undefined') {\n      this.lastValue = defaultValue;\n      this.hasValue = true;\n    }\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      if (this.resultSelector) {\n        this._tryResultSelector(value, index);\n        return;\n      }\n      this.lastValue = value;\n      this.hasValue = true;\n    }\n  }\n\n  private _tryPredicate(value: T, index: number) {\n    let result: any;\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      if (this.resultSelector) {\n        this._tryResultSelector(value, index);\n        return;\n      }\n      this.lastValue = value;\n      this.hasValue = true;\n    }\n  }\n\n  private _tryResultSelector(value: T, index: number) {\n    let result: any;\n    try {\n      result = (<any>this).resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.lastValue = result;\n    this.hasValue = true;\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    if (this.hasValue) {\n      destination.next(this.lastValue);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T>> {\n  return function materializeOperatorFunction(source: Observable<T>) {\n    return source.lift(new MaterializeOperator());\n  };\n}\n\nclass MaterializeOperator<T> implements Operator<T, Notification<T>> {\n  call(subscriber: Subscriber<Notification<T>>, source: any): any {\n    return source.subscribe(new MaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MaterializeSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<Notification<T>>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.destination.next(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    const destination = this.destination;\n    destination.next(Notification.createError(err));\n    destination.complete();\n  }\n\n  protected _complete() {\n    const destination = this.destination;\n    destination.next(Notification.createComplete());\n    destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport function scan<T>(accumulator: (acc: T[], value: T, index: number) => T[], seed?: T[]): OperatorFunction<T, T[]>;\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: T | R): OperatorFunction<T, R> {\n  let hasSeed = false;\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n\n  return function scanOperatorFunction(source: Observable<T>): Observable<R> {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\n\nclass ScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => R, private seed?: T | R, private hasSeed: boolean = false) {}\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ScanSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n\n  get seed(): T | R {\n    return this._seed;\n  }\n\n  set seed(value: T | R) {\n    this.hasSeed = true;\n    this._seed = value;\n  }\n\n  constructor(destination: Subscriber<R>, private accumulator: (acc: R, value: T, index: number) => R, private _seed: T | R,\n              private hasSeed: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  }\n\n  private _tryNext(value: T): void {\n    const index = this.index++;\n    let result: any;\n    try {\n      result = this.accumulator(<R>this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n    this.seed = result;\n    this.destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return function takeLastOperatorFunction(source: Observable<T>): Observable<T> {\n    if (count === 0) {\n      return new EmptyObservable<T>();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nclass TakeLastOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeLastSubscriber<T> extends Subscriber<T> {\n  private ring: Array<T> = new Array();\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const ring = this.ring;\n    const total = this.total;\n    const count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      const index = count % total;\n      ring[index] = value;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    let count = this.count;\n\n    if (count > 0) {\n      const total = this.count >= this.total ? this.total : this.count;\n      const ring  = this.ring;\n\n      for (let i = 0; i < total; i++) {\n        const idx = (count++) % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { ArrayObservable } from './ArrayObservable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(v1: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | IScheduler | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | IScheduler | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: IScheduler = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <IScheduler>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll(concurrent)(new ArrayObservable(<any>observables, scheduler)) as Observable<R>;\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\nimport { merge as mergeStatic } from '../observable/merge';\n\nexport { merge as mergeStatic } from '../observable/merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T>(concurrent?: number, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: Array<ObservableInput<T> | IScheduler | number>): MonoTypeOperatorFunction<T>;\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(mergeStatic(source, ...observables));\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMapTo<T, R>(observable: ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nexport function mergeMapTo<T, I, R>(innerObservable: Observable<I>,\n                                    resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                    concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  if (typeof resultSelector === 'number') {\n    concurrent = <number>resultSelector;\n    resultSelector = null;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapToOperator(innerObservable, <any>resultSelector, concurrent));\n}\n\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nexport class MergeMapToOperator<T, I, R> implements Operator<Observable<T>, R> {\n  constructor(private ish: ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private ish: ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      const resultSelector = this.resultSelector;\n      const index = this.index++;\n      const ish = this.ish;\n      const destination = this.destination;\n\n      this.active++;\n      this._innerSub(ish, destination, resultSelector, value, index);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: ObservableInput<I>,\n                    destination: PartialObserver<I>,\n                    resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n                    value: T,\n                    index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private trySelectResult(outerValue: T, innerValue: I,\n                          outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    let result: R;\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T) => Observable<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T) => Observable<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T) => Observable<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const ish = tryCatch(this.accumulator)(this.acc, value);\n      const destination = this.destination;\n      if (ish === errorObject) {\n        destination.error(errorObject.e);\n      } else {\n        this.active++;\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any, value: T, index: number): void {\n    this.add(subscribeToResult<T, R>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  };\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  _isComplete = false;\n\n  constructor(protected source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { FromObservable } from '../observable/FromObservable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { isArray } from '../util/isArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<T, R>(v: ObservableInput<R>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, R> ;\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>> |\n                                                       ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<Observable<any>>>nextSources[0];\n  }\n\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                              Array<ObservableInput<any>> |\n                                                              ((...values: Array<any>) => R)>): Observable<R> {\n  let source: ObservableInput<any> = null;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<ObservableInput<any>>>nextSources[0];\n  }\n  source = nextSources.shift();\n\n  return new FromObservable(source, null).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\n  constructor(private nextSources: Array<ObservableInput<any>>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\n\nclass OnErrorResumeNextSubscriber<T, R> extends OuterSubscriber<T, R> {\n  constructor(protected destination: Subscriber<T>,\n              private nextSources: Array<ObservableInput<any>>) {\n    super(destination);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this.subscribeToNextSource();\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _error(err: any): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _complete(): void {\n    this.subscribeToNextSource();\n  }\n\n  private subscribeToNextSource(): void {\n    const next = this.nextSources.shift();\n    if (next) {\n      this.add(subscribeToResult(this, next));\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return (source: Observable<T>) => source.lift(new PairwiseOperator());\n}\n\nclass PairwiseOperator<T> implements Operator<T, [T, T]> {\n  call(subscriber: Subscriber<[T, T]>, source: any): any {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass PairwiseSubscriber<T> extends Subscriber<T> {\n  private prev: T;\n  private hasPrev: boolean = false;\n\n  constructor(destination: Subscriber<[T, T]>) {\n    super(destination);\n  }\n\n  _next(value: T): void {\n    if (this.hasPrev) {\n      this.destination.next([this.prev, value]);\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, ISubscription } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n/**\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    if (subscription && !(<ISubscription>subscription).closed) {\n      subscriber.next(this._value);\n    }\n    return subscription;\n  }\n\n  getValue(): T {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  }\n\n  next(value: T): void {\n    super.next(this._value = value);\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private value: T = null;\n  private hasNext: boolean = false;\n  private hasCompleted: boolean = false;\n\n  protected _subscribe(subscriber: Subscriber<any>): Subscription {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n    return super._subscribe(subscriber);\n  }\n\n  next(value: T): void {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  }\n\n  error(error: any): void {\n    if (!this.hasCompleted) {\n      super.error(error);\n    }\n  }\n\n  complete(): void {\n    this.hasCompleted = true;\n    if (this.hasNext) {\n      super.next(this.value);\n    }\n    super.complete();\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: QueueAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\n\nexport const queue = new QueueScheduler(QueueAction);\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { Subject } from './Subject';\nimport { IScheduler } from './Scheduler';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: ReplayEvent<T>[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: IScheduler) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n  }\n\n  next(value: T): void {\n    const now = this._getNow();\n    this._events.push(new ReplayEvent(now, value));\n    this._trimBufferThenGetEvents();\n    super.next(value);\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const _events = this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    const len = _events.length;\n    for (let i = 0; i < len && !subscriber.closed; i++) {\n      subscriber.next(_events[i].value);\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = this._events;\n\n    let eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport function race<T>(observables: Array<Observable<T>>): Observable<T>;\nexport function race<T>(observables: Array<Observable<any>>): Observable<T>;\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;\nexport function race<T>(...observables: Array<Observable<any> | Array<Observable<any>>>): Observable<T> {\n  // if the only argument is an array, it was most likely called with\n  // `race([obs1, obs2, ...])`\n  if (observables.length === 1) {\n    if (isArray(observables[0])) {\n      observables = <Array<Observable<any>>>observables[0];\n    } else {\n      return <Observable<any>>observables[0];\n    }\n  }\n\n  return new ArrayObservable<T>(<any>observables).lift(new RaceOperator<T>());\n}\n\nexport class RaceOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RaceSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class RaceSubscriber<T> extends OuterSubscriber<T, T> {\n  private hasFirst: boolean = false;\n  private observables: Observable<any>[] = [];\n  private subscriptions: Subscription[] = [];\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(observable: any): void {\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      for (let i = 0; i < len && !this.hasFirst; i++) {\n        let observable = observables[i];\n        let subscription = subscribeToResult(this, observable, observable, i);\n\n        if (this.subscriptions) {\n          this.subscriptions.push(subscription);\n        }\n        this.add(subscription);\n      }\n      this.observables = null;\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    if (!this.hasFirst) {\n      this.hasFirst = true;\n\n      for (let i = 0; i < this.subscriptions.length; i++) {\n        if (i !== outerIndex) {\n          let subscription = this.subscriptions[i];\n\n          subscription.unsubscribe();\n          this.remove(subscription);\n        }\n      }\n\n      this.subscriptions = null;\n    }\n\n    this.destination.next(innerValue);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nexport function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return new EmptyObservable<T>();\n    } else if (count < 0) {\n      return source.lift(new RepeatOperator(-1, source));\n    } else {\n      return source.lift(new RepeatOperator(count - 1, source));\n    }\n  };\n}\n\nclass RepeatOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  complete() {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.complete();\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RepeatWhenOperator(notifier));\n}\n\nclass RepeatWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (notifications: Observable<any>) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private notifications: Subject<any>;\n  private retries: Observable<any>;\n  private retriesSubscription: Subscription;\n  private sourceIsBeingSubscribedTo: boolean = true;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (notifications: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return super.complete();\n    }\n  }\n\n  complete() {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      } else if (this.retriesSubscription.closed) {\n        return super.complete();\n      }\n\n      this._unsubscribeAndRecycle();\n      this.notifications.next();\n    }\n  }\n\n  protected _unsubscribe() {\n    const { notifications, retriesSubscription } = this;\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = null;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n    this.retries = null;\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { notifications, retries, retriesSubscription } = this;\n    this.notifications = null;\n    this.retries = null;\n    this.retriesSubscription = null;\n    super._unsubscribeAndRecycle();\n    this.notifications = notifications;\n    this.retries = retries;\n    this.retriesSubscription = retriesSubscription;\n    return this;\n  }\n\n  private subscribeToRetries() {\n    this.notifications = new Subject();\n    const retries = tryCatch(this.notifier)(this.notifications);\n    if (retries === errorObject) {\n      return super.complete();\n    }\n    this.retries = retries;\n    this.retriesSubscription = subscribeToResult(this, retries);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryWhenOperator(notifier, source));\n}\n\nclass RetryWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (errors: Observable<any>) => Observable<any>,\n              protected source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetryWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private errors: Subject<any>;\n  private retries: Observable<any>;\n  private retriesSubscription: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (errors: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  error(err: any) {\n    if (!this.isStopped) {\n\n      let errors = this.errors;\n      let retries: any = this.retries;\n      let retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject();\n        retries = tryCatch(this.notifier)(errors);\n        if (retries === errorObject) {\n          return super.error(errorObject.e);\n        }\n        retriesSubscription = subscribeToResult(this, retries);\n      } else {\n        this.errors = null;\n        this.retriesSubscription = null;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n\n      errors.next(err);\n    }\n  }\n\n  protected _unsubscribe() {\n    const { errors, retriesSubscription } = this;\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = null;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n    this.retries = null;\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const { errors, retries, retriesSubscription } = this;\n    this.errors = null;\n    this.retries = null;\n    this.retriesSubscription = null;\n\n    this._unsubscribeAndRecycle();\n\n    this.errors = errors;\n    this.retries = retries;\n    this.retriesSubscription = retriesSubscription;\n\n    this.source.subscribe(this);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleOperator(notifier));\n}\n\nclass SampleOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const sampleSubscriber = new SampleSubscriber(subscriber);\n    const subscription = source.subscribe(sampleSubscriber);\n    subscription.add(subscribeToResult(sampleSubscriber, this.notifier));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private value: T;\n  private hasValue: boolean = false;\n\n  protected _next(value: T) {\n    this.value = value;\n    this.hasValue = true;\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { async } from '../scheduler/async';\nimport { TeardownLogic } from '../Subscription';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport function sampleTime<T>(period: number, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));\n}\n\nclass SampleTimeOperator<T> implements Operator<T, T> {\n  constructor(private period: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleTimeSubscriber<T> extends Subscriber<T> {\n  lastValue: T;\n  hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private period: number,\n              private scheduler: IScheduler) {\n    super(destination);\n    this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n  }\n\n  protected _next(value: T) {\n    this.lastValue = value;\n    this.hasValue = true;\n  }\n\n  notifyNext() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  }\n}\n\nfunction dispatchNotification<T>(this: Action<any>, state: any) {\n  let { subscriber, period } = state;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n","import { Operator } from '../Operator';\nimport { Observer } from '../Observer';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport function sequenceEqual<T>(compareTo: Observable<T>,\n                                 comparor?: (a: T, b: T) => boolean): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new SequenceEqualOperator(compareTo, comparor));\n}\n\nexport class SequenceEqualOperator<T> implements Operator<T, boolean> {\n  constructor(private compareTo: Observable<T>,\n              private comparor: (a: T, b: T) => boolean) {\n  }\n\n  call(subscriber: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n  private _a: T[] = [];\n  private _b: T[] = [];\n  private _oneComplete = false;\n\n  constructor(destination: Observer<R>,\n              private compareTo: Observable<T>,\n              private comparor: (a: T, b: T) => boolean) {\n    super(destination);\n    this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  protected _next(value: T): void {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n      this.checkValues();\n    }\n  }\n\n  public _complete(): void {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  }\n\n  checkValues() {\n    const { _a, _b, comparor } = this;\n    while (_a.length > 0 && _b.length > 0) {\n      let a = _a.shift();\n      let b = _b.shift();\n      let areEqual = false;\n      if (comparor) {\n        areEqual = tryCatch(comparor)(a, b);\n        if (areEqual === errorObject) {\n          this.destination.error(errorObject.e);\n        }\n      } else {\n        areEqual = a === b;\n      }\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  }\n\n  emit(value: boolean) {\n    const { destination } = this;\n    destination.next(value);\n    destination.complete();\n  }\n\n  nextB(value: T) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n      this.checkValues();\n    }\n  }\n}\n\nclass SequenceEqualCompareToSubscriber<T, R> extends Subscriber<T> {\n  constructor(destination: Observer<R>, private parent: SequenceEqualSubscriber<T, R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.parent.nextB(value);\n  }\n\n  protected _error(err: any): void {\n    this.parent.error(err);\n  }\n\n  protected _complete(): void {\n    this.parent._complete();\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observer } from '../Observer';\nimport { EmptyError } from '../util/EmptyError';\nimport { TeardownLogic } from '../Subscription';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source));\n}\n\nclass SingleOperator<T> implements Operator<T, T> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SingleSubscriber<T> extends Subscriber<T> {\n  private seenValue: boolean = false;\n  private singleValue: T;\n  private index: number = 0;\n\n  constructor(destination: Observer<T>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  private applySingleValue(value: T): void {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  }\n\n  private tryNext(value: T, index: number): void {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipOperator(count));\n}\n\nclass SkipOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipSubscriber<T> extends Subscriber<T> {\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(x: T) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier));\n}\n\nclass SkipUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private hasValue: boolean = false;\n  private isInnerStopped: boolean = false;\n\n  constructor(destination: Subscriber<any>,\n              notifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, notifier));\n  }\n\n  protected _next(value: T) {\n    if (this.hasValue) {\n      super._next(value);\n    }\n  }\n\n  protected _complete() {\n    if (this.isInnerStopped) {\n      super._complete();\n    } else {\n      this.unsubscribe();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.hasValue = true;\n  }\n\n  notifyComplete(): void {\n    this.isInnerStopped = true;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipWhileOperator(predicate));\n}\n\nclass SkipWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipWhileSubscriber<T> extends Subscriber<T> {\n  private skipping: boolean = true;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  }\n\n  private tryCallPredicate(value: T): void {\n    try {\n      const result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, I | R> {\n  return function switchMapOperatorFunction(source: Observable<T>): Observable<I | R> {\n    return source.lift(new SwitchMapOperator(project, resultSelector));\n  };\n}\n\nclass SwitchMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(result: ObservableInput<I>, value: T, index: number) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _tryNotifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): void {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<T, R>(observable: ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(innerObservable: Observable<I>,\n                                     resultSelector?: (outerValue: T,\n                                                       innerValue: I,\n                                                       outerIndex: number,\n                                                       innerIndex: number) => R): OperatorFunction<T, I | R> {\n  return (source: Observable<T>) => source.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\n\nclass SwitchMapToOperator<T, I, R> implements Operator<T, I> {\n  constructor(private observable: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private inner: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: any) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, this.inner, value, this.index++));\n  }\n\n  protected _complete() {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private tryResultSelector(outerValue: T, innerValue: I,\n                            outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    let result: R;\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return new EmptyObservable<T>();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  constructor(destination: Subscriber<any>,\n              private notifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, notifier));\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeWhileOperator(predicate));\n}\n\nclass TakeWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeWhileSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    let result: boolean;\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this.nextOrComplete(value, result);\n  }\n\n  private nextOrComplete(value: T, predicateResult: boolean): void {\n    const destination = this.destination;\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { PartialObserver } from '../Observer';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function tap<T>(next: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DoSubscriber<T> extends Subscriber<T> {\n\n  private safeSubscriber: Subscriber<T>;\n\n  constructor(destination: Subscriber<T>,\n              nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              error?: (e: any) => void,\n              complete?: () => void) {\n    super(destination);\n\n    const safeSubscriber = new Subscriber<T>(nextOrObserver, error, complete);\n    safeSubscriber.syncErrorThrowable = true;\n    this.add(safeSubscriber);\n    this.safeSubscriber = safeSubscriber;\n  }\n\n  protected _next(value: T): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.next(value);\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.next(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.error(err);\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.complete();\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\nexport interface ThrottleConfig {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport const defaultThrottleConfig: ThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<number>,\n                            config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n}\n\nclass ThrottleOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private throttled: Subscription;\n  private _trailingValue: T;\n  private _hasTrailingValue = false;\n\n  constructor(protected destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private _leading: boolean,\n              private _trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.throttled) {\n      if (this._trailing) {\n        this._hasTrailingValue = true;\n        this._trailingValue = value;\n      }\n    } else {\n      const duration = this.tryDurationSelector(value);\n      if (duration) {\n        this.add(this.throttled = subscribeToResult(this, duration));\n      }\n      if (this._leading) {\n        this.destination.next(value);\n        if (this._trailing) {\n          this._hasTrailingValue = true;\n          this._trailingValue = value;\n        }\n      }\n    }\n  }\n\n  private tryDurationSelector(value: T): SubscribableOrPromise<any> {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  }\n\n  protected _unsubscribe() {\n    const { throttled, _trailingValue, _hasTrailingValue, _trailing } = this;\n\n    this._trailingValue = null;\n    this._hasTrailingValue = false;\n\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n  }\n\n  private _sendTrailing() {\n    const { destination, throttled, _trailing, _trailingValue, _hasTrailingValue } = this;\n    if (throttled && _trailing && _hasTrailingValue) {\n      destination.next(_trailingValue);\n      this._trailingValue = null;\n      this._hasTrailingValue = false;\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this._sendTrailing();\n    this._unsubscribe();\n  }\n\n  notifyComplete(): void {\n    this._sendTrailing();\n    this._unsubscribe();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: IScheduler = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { OperatorFunction } from '../interfaces';\n\nexport function timeInterval<T>(scheduler: IScheduler = async): OperatorFunction<T, TimeInterval<T>> {\n  return (source: Observable<T>) => source.lift(new TimeIntervalOperator(scheduler));\n}\n\nexport class TimeInterval<T> {\n  constructor(public value: T, public interval: number) {\n\n  }\n};\n\nclass TimeIntervalOperator<T> implements Operator<T, TimeInterval<T>> {\n  constructor(private scheduler: IScheduler) {\n\n  }\n\n  call(observer: Subscriber<TimeInterval<T>>, source: any): any {\n    return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeIntervalSubscriber<T> extends Subscriber<T> {\n  private lastTime: number = 0;\n\n  constructor(destination: Subscriber<TimeInterval<T>>, private scheduler: IScheduler) {\n    super(destination);\n\n    this.lastTime = scheduler.now();\n  }\n\n  protected _next(value: T) {\n    let now = this.scheduler.now();\n    let span = now - this.lastTime;\n    this.lastTime = now;\n\n    this.destination.next(new TimeInterval(value, span));\n  }\n}\n","/**\r\n * An error thrown when duetime elapses.\r\n *\r\n * @see {@link timeout}\r\n *\r\n * @class TimeoutError\r\n */\r\nexport class TimeoutError extends Error {\r\n  constructor() {\r\n    const err: any = super('Timeout has occurred');\r\n    (<any> this).name = err.name = 'TimeoutError';\r\n    (<any> this).stack = err.stack;\r\n    (<any> this).message = err.message;\r\n  }\r\n}\r\n","import { Action } from '../scheduler/Action';\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nexport function timeout<T>(due: number | Date,\n                           scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  const absoluteTimeout = isDate(due);\n  const waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n  return (source: Observable<T>) => source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError()));\n}\n\nclass TimeoutOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private scheduler: IScheduler,\n              private errorInstance: TimeoutError) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutSubscriber<T>(\n      subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutSubscriber<T> extends Subscriber<T> {\n\n  private action: Action<TimeoutSubscriber<T>> = null;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private scheduler: IScheduler,\n              private errorInstance: TimeoutError) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T>(subscriber: TimeoutSubscriber<T>): void {\n    subscriber.error(subscriber.errorInstance);\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<Action<TimeoutSubscriber<T>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<Action<TimeoutSubscriber<T>>> this.scheduler.schedule(\n        TimeoutSubscriber.dispatchTimeout, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  protected _unsubscribe() {\n    this.action = null;\n    this.scheduler = null;\n    this.errorInstance = null;\n  }\n}\n","import { Action } from '../scheduler/Action';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { TeardownLogic } from '../Subscription';\nimport { Observable, ObservableInput } from '../Observable';\nimport { isDate } from '../util/isDate';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function timeoutWith<T>(due: number | Date, withObservable: ObservableInput<T>, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: IScheduler): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith<T, R>(due: number | Date,\n                                  withObservable: ObservableInput<R>,\n                                  scheduler: IScheduler = async): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nclass TimeoutWithOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private withObservable: ObservableInput<any>,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutWithSubscriber(\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private action: Action<TimeoutWithSubscriber<T, R>> = null;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private withObservable: ObservableInput<any>,\n              private scheduler: IScheduler) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\n    const { withObservable } = subscriber;\n    (<any> subscriber)._unsubscribeAndRecycle();\n    subscriber.add(subscribeToResult(subscriber, withObservable));\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<Action<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<Action<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule(\n        TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  protected _unsubscribe() {\n    this.action = null;\n    this.scheduler = null;\n    this.withObservable = null;\n  }\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\nimport { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { Operator } from '../Operator';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator(windowBoundaries));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowBoundaries: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    const windowSubscriber = new WindowSubscriber(subscriber);\n    const sourceSubscription = source.subscribe(windowSubscriber);\n    if (!sourceSubscription.closed) {\n      windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));\n    }\n    return sourceSubscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n\n  private window: Subject<T> = new Subject<T>();\n\n  constructor(destination: Subscriber<Observable<T>>) {\n    super(destination);\n    destination.next(this.window);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this._complete();\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.window = null;\n  }\n\n  private openWindow(): void  {\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n    const destination = this.destination;\n    const newWindow = this.window = new Subject<T>();\n    destination.next(newWindow);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Same as example above but with maxWindowCount instead of take</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000, 2) // each window has still at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(windowTimeSpan: number,\n                              scheduler?: IScheduler): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: IScheduler): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: IScheduler): OperatorFunction<T, Observable<T>>;\n\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\n  let scheduler: IScheduler = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return function windowTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: IScheduler;\n}\n\ninterface TimeSpanOnlyState<T> {\n    window: CountedSubject<T>;\n    windowTimeSpan: number;\n    subscriber: WindowTimeSubscriber<T>;\n  }\n\ninterface CloseWindowContext<T> {\n  action: Action<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface CloseState<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: CountedSubject<T>;\n  context: CloseWindowContext<T>;\n}\n\nclass CountedSubject<T> extends Subject<T> {\n  private _numberOfNextedValues: number = 0;\n\n  next(value?: T): void {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues(): number {\n    return this._numberOfNextedValues;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: CountedSubject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: IScheduler) {\n    super(destination);\n\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T): void {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  protected _error(err: any): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  public openWindow(): CountedSubject<T> {\n    const window = new CountedSubject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  public closeWindow(window: CountedSubject<T>): void {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: Action<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation<T>(this: Action<CreationState<T>>, state: CreationState<T>): void {\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\n  const { subscriber, window, context } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  protected _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n\n      const { closingSelector } = this;\n      const closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        const window = new Subject<T>();\n        const subscription = new Subscription();\n        const context = { window, subscription };\n        this.contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          (<any> innerSubscription).context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window);\n\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowWhenOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator<T>(closingSelector));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n  private window: Subject<T>;\n  private closingNotification: Subscription;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openWindow();\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n\n  private unsubscribeClosingNotification(): void {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n\n  private openWindow(innerSub: InnerSubscriber<T, any> = null): void {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    const window = this.window = new Subject<T>();\n    this.destination.next(window);\n\n    const closingNotifier = tryCatch(this.closingSelector)();\n    if (closingNotifier === errorObject) {\n      const err = errorObject.e;\n      this.destination.error(err);\n      this.window.error(err);\n    } else {\n      this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function withLatestFrom<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function withLatestFrom<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function withLatestFrom<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function withLatestFrom<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function withLatestFrom<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nexport function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    let project: any;\n    if (typeof args[args.length - 1] === 'function') {\n      project = args.pop();\n    }\n    const observables = <Observable<any>[]>args;\n    return source.lift(new WithLatestFromOperator(observables, project));\n  };\n}\n\nclass WithLatestFromOperator<T, R> implements Operator<T, R> {\n  constructor(private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WithLatestFromSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private values: any[];\n  private toRespond: number[] = [];\n\n  constructor(destination: Subscriber<R>,\n              private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n    super(destination);\n    const len = observables.length;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.toRespond.push(i);\n    }\n\n    for (let i = 0; i < len; i++) {\n      let observable = observables[i];\n      this.add(subscribeToResult<T, R>(this, observable, <any>observable, i));\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.values[outerIndex] = innerValue;\n    const toRespond = this.toRespond;\n    if (toRespond.length > 0) {\n      const found = toRespond.indexOf(outerIndex);\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  }\n\n  notifyComplete() {\n    // noop\n  }\n\n  protected _next(value: T) {\n    if (this.toRespond.length === 0) {\n      const args = [value, ...this.values];\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next(args);\n      }\n    }\n  }\n\n  private _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\nexport function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nexport function zip<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return function zipOperatorFunction(source: Observable<T>) {\n    return source.lift.call(zipStatic<R>(source, ...observables));\n  };\n}\n\n/* tslint:disable:max-line-length */\nexport function zipStatic<T, R>(v1: ObservableInput<T>, project: (v1: T) => R): Observable<R>;\nexport function zipStatic<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;\n\nexport function zipStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function zipStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function zipStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function zipStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function zipStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function zipStatic<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function zipStatic<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function zipStatic<T, R>(array: ObservableInput<T>[], project: (...values: Array<T>) => R): Observable<R>;\nexport function zipStatic<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;\n\nexport function zipStatic<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport function zipStatic<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function zipStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zipStatic<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R> {\n  const project = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof project === 'function') {\n    observables.pop();\n  }\n  return new ArrayObservable(observables).lift(new ZipOperator(project));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  project: (...values: Array<any>) => R;\n\n  constructor(project?: (...values: Array<any>) => R) {\n    this.project = project;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private values: any;\n  private project: (...values: Array<any>) => R;\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              project?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.project = (typeof project === 'function') ? project : null;\n    this.values = values;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        this.add(iterator.subscribe(iterator, i));\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.project) {\n      this._tryProject(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  }\n\n  protected _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted() {\n    const nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends OuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift(), done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe(value: any, index: number) {\n    return subscribeToResult<any, any>(this, this.observable, this, index);\n  }\n}\n","export { audit } from './operators/audit';\nexport { auditTime } from './operators/auditTime';\nexport { buffer } from './operators/buffer';\nexport { bufferCount } from './operators/bufferCount';\nexport { bufferTime } from './operators/bufferTime';\nexport { bufferToggle } from './operators/bufferToggle';\nexport { bufferWhen } from './operators/bufferWhen';\nexport { catchError } from './operators/catchError';\nexport { combineAll } from './operators/combineAll';\nexport { combineLatest } from './operators/combineLatest';\nexport { concat } from './operators/concat';\nexport { concatAll } from './operators/concatAll';\nexport { concatMap } from './operators/concatMap';\nexport { concatMapTo } from './operators/concatMapTo';\nexport { count } from './operators/count';\nexport { debounce } from './operators/debounce';\nexport { debounceTime } from './operators/debounceTime';\nexport { defaultIfEmpty } from './operators/defaultIfEmpty';\nexport { delay } from './operators/delay';\nexport { delayWhen } from './operators/delayWhen';\nexport { dematerialize } from './operators/dematerialize';\nexport { distinct } from './operators/distinct';\nexport { distinctUntilChanged } from './operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './operators/distinctUntilKeyChanged';\nexport { elementAt } from './operators/elementAt';\nexport { every } from './operators/every';\nexport { exhaust } from './operators/exhaust';\nexport { exhaustMap } from './operators/exhaustMap';\nexport { expand } from './operators/expand';\nexport { filter } from './operators/filter';\nexport { finalize } from './operators/finalize';\nexport { find } from './operators/find';\nexport { findIndex } from './operators/findIndex';\nexport { first } from './operators/first';\nexport { groupBy } from './operators/groupBy';\nexport { ignoreElements } from './operators/ignoreElements';\nexport { isEmpty } from './operators/isEmpty';\nexport { last } from './operators/last';\nexport { map } from './operators/map';\nexport { mapTo } from './operators/mapTo';\nexport { materialize } from './operators/materialize';\nexport { max } from './operators/max';\nexport { merge } from './operators/merge';\nexport { mergeAll } from './operators/mergeAll';\nexport { mergeMap } from './operators/mergeMap';\nexport { mergeMap as flatMap } from './operators/mergeMap';\nexport { mergeMapTo } from './operators/mergeMapTo';\nexport { mergeScan } from './operators/mergeScan';\nexport { min } from './operators/min';\nexport { multicast } from './operators/multicast';\nexport { observeOn } from './operators/observeOn';\nexport { onErrorResumeNext } from './operators/onErrorResumeNext';\nexport { pairwise } from './operators/pairwise';\nexport { partition } from './operators/partition';\nexport { pluck } from './operators/pluck';\nexport { publish } from './operators/publish';\nexport { publishBehavior } from './operators/publishBehavior';\nexport { publishLast } from './operators/publishLast';\nexport { publishReplay } from './operators/publishReplay';\nexport { race } from './operators/race';\nexport { reduce } from './operators/reduce';\nexport { repeat } from './operators/repeat';\nexport { repeatWhen } from './operators/repeatWhen';\nexport { retry } from './operators/retry';\nexport { retryWhen } from './operators/retryWhen';\nexport { refCount } from './operators/refCount';\nexport { sample } from './operators/sample';\nexport { sampleTime } from './operators/sampleTime';\nexport { scan } from './operators/scan';\nexport { sequenceEqual } from './operators/sequenceEqual';\nexport { share } from './operators/share';\nexport { shareReplay } from './operators/shareReplay';\nexport { single } from './operators/single';\nexport { skip } from './operators/skip';\nexport { skipLast } from './operators/skipLast';\nexport { skipUntil } from './operators/skipUntil';\nexport { skipWhile } from './operators/skipWhile';\nexport { startWith } from './operators/startWith';\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\nexport { switchAll } from './operators/switchAll';\nexport { switchMap } from './operators/switchMap';\nexport { switchMapTo } from './operators/switchMapTo';\nexport { take } from './operators/take';\nexport { takeLast } from './operators/takeLast';\nexport { takeUntil } from './operators/takeUntil';\nexport { takeWhile } from './operators/takeWhile';\nexport { tap } from './operators/tap';\nexport { throttle } from './operators/throttle';\nexport { throttleTime } from './operators/throttleTime';\nexport { timeInterval } from './operators/timeInterval';\nexport { timeout } from './operators/timeout';\nexport { timeoutWith } from './operators/timeoutWith';\nexport { timestamp } from './operators/timestamp';\nexport { toArray } from './operators/toArray';\nexport { window } from './operators/window';\nexport { windowCount } from './operators/windowCount';\nexport { windowTime } from './operators/windowTime';\nexport { windowToggle } from './operators/windowToggle';\nexport { windowWhen } from './operators/windowWhen';\nexport { withLatestFrom } from './operators/withLatestFrom';\nexport { zip } from './operators/zip';\nexport { zipAll } from './operators/zipAll';\n","import { Directive, EventEmitter, Output } from '@angular/core';\nexport class NgxHmCarouselItemDirective {\n   clickEvent = new EventEmitter<number>();\nconstructor() { }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngx-hm-carousel-item]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'clickEvent': [{ type: Output, args: ['ngx-hm-carousel-item', ] },],\n};\n}\n\nfunction NgxHmCarouselItemDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nNgxHmCarouselItemDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgxHmCarouselItemDirective.ctorParameters;\n/** @type {?} */\nNgxHmCarouselItemDirective.propDecorators;\n/** @type {?} */\nNgxHmCarouselItemDirective.prototype.clickEvent;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { isPlatformBrowser } from '@angular/common';\n/**\n * @param {?} variableId\n * @return {?}\n */\nexport function onlyOnBrowser(variableId) {\n  return function (target, key, descriptor) {\n    const /** @type {?} */ originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n      if (isPlatformBrowser(this[variableId])) {\n        return originalMethod.apply(this, args);\n      }\n    };\n    return descriptor;\n  };\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Inject,\n  Input,\n  OnDestroy,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { interval } from 'rxjs/observable/interval';\nimport { bufferCount, debounceTime, merge, switchMap, takeUntil, tap } from 'rxjs/operators';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport { NgxHmCarouselItemDirective } from './ngx-hm-carousel-item.directive';\nimport { onlyOnBrowser } from './only-on.browser';\n\n// if the pane is paned .25, switch to the next pane.\nconst /** @type {?} */ PANBOUNDARY = 0.15;\nexport class NgxHmCarouselComponent implements AfterViewInit, AfterContentInit, OnDestroy {\n   parentChild;\nprivate btnPrev: ElementRef;\nprivate btnNext: ElementRef;\n   items: NgxHmCarouselItemDirective[];\n   contentPrev: TemplateRef<any>;\n   contentNext: TemplateRef<any>;\n   dotElm: TemplateRef<any>;\n   progressElm: TemplateRef<any>;\n\n   infinite = false;\n   mourseEnable = false;\n   speed = 5000;\n   delay = 8000;\n   direction: 'left' | 'right' = 'right';\nprivate _showNum = 1;\nprivate isAutoNum = false;\n/**\n * @param {?} value\n * @return {?}\n */\nset showNum(value: number | 'auto') {\n    if (value === 'auto') {\n      this.isAutoNum = true;\n      this._showNum = this.getWindowWidthToNum();\n    } else {\n      this._showNum = value;\n    }\n  }\n   scrollNum = 1;\n   isDragMany = false;\nprivate _viewIndex = 0;\n/**\n * @param {?} value\n * @return {?}\n */\nset currentIndex(value) {\n    this._viewIndex = value;\n    if (this.itemsElm) {\n      this.drawView(this._viewIndex);\n    }\n  }\n/**\n * @return {?}\n */\nget currentIndex() {\n    return this._viewIndex;\n  }\nprivate _autoplay = false;\n/**\n * @param {?} value\n * @return {?}\n */\nset autoplay(value) {\n    if (isPlatformBrowser(this.platformId)) {\n      if (this.itemsElm) {\n        this.progressWidth = 0;\n        if (value) {\n          this.sub$ = this.doNext.subscribe();\n        } else {\n          if (this.sub$) this.sub$.unsubscribe();\n        }\n      }\n    }\n    this._autoplay = value;\n  }\n/**\n * @return {?}\n */\nget autoplay() {\n    return this._autoplay;\n  }\n\n   indexChanged = new EventEmitter();\nprivate _porgressWidth = 0;\n/**\n * @param {?} value\n * @return {?}\n */\nset progressWidth(value) {\n    if (this.progressElm !== undefined && this.autoplay) {\n      this._porgressWidth = value;\n    }\n  }\n/**\n * @return {?}\n */\nget progressWidth() {\n    return this._porgressWidth;\n  }\nprivate rootElm: HTMLDivElement;\nprivate containerElm: HTMLDivElement;\nprivate itemsElm: Array<HTMLDivElement>;\nprivate hammer: HammerManager;\nprivate elmWidth = 0;\nprivate isInContainer = false;\nprivate restart = new BehaviorSubject<any>(null);\nprivate stopEvent = new Subject<any>();\nprivate mostRightIndex = 0;\nprivate doNext: Observable<any>;\nprivate sub$: Subscription;\nprivate prePanMove: boolean;\npublic dots: Array<number>;\nprivate nextListener: () => void;\nprivate prevListener: () => void;\n/**\n * @param {?} event\n * @return {?}\n */\nprivate onResize(event) {\n    this.setViewWidth();\n    this.drawView(this.currentIndex);\n  }\n/**\n * @param {?} platformId\n * @param {?} _renderer\n */\nconstructor(\nprivate platformId: Object,\nprivate _renderer: Renderer2) { }\n/**\n * @return {?}\n */\n@onlyOnBrowser('platformId')\n  ngAfterContentInit(): void {\n    this.initVariable();\n  }\n/**\n * @return {?}\n */\n@onlyOnBrowser('platformId')\n  ngAfterViewInit() {\n    this.setViewWidth(true);\n    this.hammer = this.bindHammer();\n    this.drawView(this.currentIndex);\n    this.bindClick();\n  }\n/**\n * @return {?}\n */\n@onlyOnBrowser('platformId')\n  ngOnDestroy() {\n    if (this.btnNext && this.btnPrev) {\n      this.nextListener();\n      this.prevListener();\n    }\n    this.hammer.destroy();\n    if (this.autoplay) {\n      this.sub$.unsubscribe();\n    }\n  }\n/**\n * @return {?}\n */\nprivate initVariable() {\n    this.rootElm = this.parentChild.nativeElement;\n    this.containerElm = /** @type {?} */(( this.rootElm.children[0] as HTMLDivElement));\n    this.itemsElm = /** @type {?} */(( Array.from(this.containerElm.children) as HTMLDivElement[]));\n\n    this.mostRightIndex = this.itemsElm.length - this._showNum;\n    if (this.dotElm) {\n      this.dots = new Array(this.itemsElm.length - (this._showNum - 1)).map((x, i) => i);\n    }\n\n    let /** @type {?} */ startEvent = this.restart.asObservable(); // .merge(this.mourseLeave); // .map(() => console.log('start'))\n    let /** @type {?} */ stopEvent = this.stopEvent.asObservable();\n    if (this.mourseEnable) {\n      const /** @type {?} */ mourseOver = fromEvent(this.containerElm, 'mouseover').pipe(\n        tap(() => this.isInContainer = true)\n      );\n      const /** @type {?} */ mourseLeave = fromEvent(this.containerElm, 'mouseleave').pipe(\n        tap(() => this.isInContainer = true)\n      );\n\n      startEvent = startEvent.pipe(\n        merge(mourseLeave)\n      );\n\n      stopEvent = stopEvent.pipe(\n        merge(mourseOver)\n      );\n    }\n    // const debounceTime = this.delay < this.speed ? this.delay : this.delay - this.speed;\n    this.doNext = startEvent.pipe(\n      debounceTime(this.delay),\n      switchMap(() =>\n        this.runProgress(20).pipe(\n          tap(() => {\n            // console.log('next');\n            if (this.direction === 'left') this.currentIndex -= this.scrollNum;\n            else this.currentIndex += this.scrollNum;\n          }),\n          takeUntil(\n            stopEvent.pipe(\n              tap(() => this.progressWidth = 0)\n            )\n          )\n        )\n      ));\n\n    if (this.autoplay) {\n      this.sub$ = this.doNext.subscribe();\n    }\n  }\n/**\n * @param {?=} isInit\n * @return {?}\n */\nprivate setViewWidth(isInit?: boolean) {\n    if (this.isAutoNum) {\n      this._showNum = this.getWindowWidthToNum();\n      this.mostRightIndex = this.itemsElm.length - this._showNum;\n      if (this.dotElm) {\n        this.dots = new Array(this.itemsElm.length - (this._showNum - 1)).map((x, i) => i);\n      }\n    }\n    this._renderer.addClass(this.containerElm, 'grab');\n    // when init check view has scroll bar\n    const /** @type {?} */ totalWidth = 0;\n    if (isInit) {\n      // remain one elm height\n      this._renderer.addClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');\n    }\n    this.elmWidth = (totalWidth + this.rootElm.clientWidth) / this._showNum;\n\n    this._renderer.removeClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');\n    this._renderer.setStyle(this.containerElm, 'width', `${this.elmWidth * this.itemsElm.length}px`);\n    this._renderer.setStyle(this.containerElm, 'position', 'relative');\n    this.itemsElm.forEach((elm: HTMLDivElement, index) => {\n      this._renderer.setStyle(elm, 'width', `${this.elmWidth}px`);\n    });\n  }\n/**\n * @return {?}\n */\nprivate bindHammer() {\n    const /** @type {?} */ hm = new Hammer(this.containerElm);\n    hm.get('pan').set({ direction: Hammer.DIRECTION_HORIZONTAL });\n\n    hm.on('panleft panright panend tap', (e: HammerInput) => {\n      this._renderer.removeClass(this.containerElm, 'transition');\n      this._renderer.addClass(this.containerElm, 'grabbing');\n      if (this.autoplay) {\n        this.stopEvent.next();\n      }\n      // console.log(e.type);\n      switch (e.type) {\n        case 'tap':\n          this.callClick(e.center.x);\n          this.callRestart();\n          this._renderer.removeClass(this.containerElm, 'grabbing');\n          break;\n        case 'panend':\n          this._renderer.removeClass(this.containerElm, 'grabbing');\n        // tslint:disable-next-line:no-switch-case-fall-through\n        case 'panleft':\n        case 'panright':\n          this.handlePan(e);\n          break;\n      }\n    });\n\n    return hm;\n  }\n/**\n * @return {?}\n */\nprivate bindClick() {\n    if (this.btnNext && this.btnPrev) {\n      this.nextListener = this._renderer.listen(this.btnNext.nativeElement, 'click', () => {\n        this.setIndex(this.currentIndex + 1);\n      });\n      this.prevListener = this._renderer.listen(this.btnPrev.nativeElement, 'click', () => {\n        this.setIndex(this.currentIndex - 1);\n      });\n    }\n  }\n/**\n * @return {?}\n */\nprivate callRestart() {\n    if (this.autoplay && !this.isInContainer) {\n      this.restart.next(null);\n    }\n  }\n/**\n * @param {?} positionX\n * @return {?}\n */\nprivate callClick(positionX) {\n    const /** @type {?} */ toIndex = this.currentIndex + Math.floor(positionX / this.elmWidth);\n    Array.from(this.items)[toIndex].clickEvent.emit(toIndex);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\nprivate drawView(index: number) {\n    this._renderer.addClass(this.containerElm, 'transition');\n    if (this.autoplay || this.infinite) {\n      this.playCycle(index);\n    } else {\n      this._viewIndex = Math.max(0, Math.min(index, this.mostRightIndex));\n    }\n    // this.containerElm.style.transform = `translate3d(${-this.currentIndex * this.elmWidth}px, 0px, 0px)`;\n    this._renderer.setStyle(this.containerElm, 'left', `${-this.currentIndex * this.elmWidth}px`);\n    this.indexChanged.emit(this.currentIndex);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\nprivate playCycle(index: any) {\n    switch (this.direction) {\n      case 'left':\n        if (index === -this.scrollNum) {\n          this._viewIndex = this.mostRightIndex;\n        } else if (index > this.mostRightIndex || index < 0) {\n          this._viewIndex = 0;\n        }\n        break;\n      case 'right':\n        if (index === this.mostRightIndex + this.scrollNum) {\n          this._viewIndex = 0;\n        } else if (index < 0 || this._viewIndex >= this.mostRightIndex) {\n          this._viewIndex = this.mostRightIndex;\n        }\n        break;\n    }\n  }\n/**\n * @param {?} e\n * @return {?}\n */\nprivate handlePan(e: HammerInput) {\n    // console.log(e.deltaX / this.elmWidth);\n    // console.log(moveNum);\n    switch (e.type) {\n      case 'panleft':\n      case 'panright':\n        // console.log(e.deltaY);\n        this.prePanMove = false;\n        if (Math.abs(e.deltaY) > 50) return;\n        // Slow down at the first and last pane.\n        if (this.outOfBound(e.type) && (!this.infinite)) {\n          e.deltaX *= 0.5;\n        }\n        this._renderer.setStyle(this.containerElm, 'left', `${-this.currentIndex * this.elmWidth + e.deltaX}px`);\n\n        if (!this.isDragMany) {\n          if (Math.abs(e.deltaX) > this.elmWidth * 0.5) {\n            if (e.deltaX > 0) {\n              this.currentIndex -= this.scrollNum;\n            } else {\n              this.currentIndex += this.scrollNum;\n            }\n            this._renderer.removeClass(this.containerElm, 'grabbing');\n            this.callRestart();\n            this.hammer.stop(true);\n            // remember prv action, to avoid hammer stop, then click\n            this.prePanMove = true;\n          }\n        }\n        break;\n      case 'panend':\n        this.callRestart();\n\n        if (Math.abs(e.deltaX) > this.elmWidth * PANBOUNDARY) {\n          const /** @type {?} */ moveNum = this.isDragMany ?\n            Math.ceil(Math.abs(e.deltaX) / this.elmWidth) : this.scrollNum;\n          if (e.deltaX > 0) {\n            this.currentIndex -= moveNum;\n          } else {\n            this.currentIndex += moveNum;\n          }\n          break;\n        } else {\n          if (!this.isDragMany && this.prePanMove) {\n            this.callClick(e.center.x);\n          }\n        }\n        this.drawView(this.currentIndex);\n        this.prePanMove = false;\n        break;\n    }\n  }\n/**\n * @param {?} index\n * @return {?}\n */\nsetIndex(index: number) {\n    if (this.autoplay) {\n      this.stopEvent.next();\n      this.restart.next('do restart');\n    }\n    this.currentIndex = index;\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nprivate outOfBound(type) {\n    switch (type) {\n      case 'panleft':\n        return this.currentIndex === this.mostRightIndex;\n      case 'panright':\n        return this.currentIndex === 0;\n    }\n  }\n/**\n * @param {?} betweenTime\n * @return {?}\n */\nprivate runProgress(betweenTime): Observable<any> {\n    const /** @type {?} */ howTimes = this.speed / betweenTime;\n    const /** @type {?} */ everyIncrease = 100 / this.speed * betweenTime;\n    // console.log('progress');\n    return interval(betweenTime).pipe(\n      tap(t => {\n        this.progressWidth = (t % howTimes) * everyIncrease;\n      }),\n      bufferCount(Math.round(this.speed / betweenTime), 0)\n    );\n  }\n/**\n * @return {?}\n */\nprivate getWindowWidthToNum() {\n    const /** @type {?} */ initNum = 3;\n    // 610\n    // if use window do check to avoid ssr problem.\n    if (window) {\n      const /** @type {?} */ windowWidth = window.innerWidth;\n      if (windowWidth > 300) {\n        return Math.floor(initNum + (windowWidth / 200));\n      }\n    }\n    return initNum;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  selector: 'ngx-hm-carousel',\n  template: `\n    <div #parentChild class=\"carousel\">\n      <ng-content select=\"[ngx-hm-carousel-container]\"></ng-content>\n      <!-- left -->\n      <div #prev *ngIf=\"contentPrev\"\n        class=\"direction left\">\n        <ng-container *ngTemplateOutlet=\"contentPrev\"></ng-container>\n      </div>\n      <!--  right -->\n      <div #next *ngIf=\"contentNext\"\n        class=\"direction right\">\n        <ng-container *ngTemplateOutlet=\"contentNext\"></ng-container>\n      </div>\n      <!-- indicators -->\n      <ul class=\"indicators\" *ngIf=\"dotElm\">\n        <li\n          *ngFor=\"let dot of dots; let i = index;\"\n          (click)=\"setIndex(i)\">\n          <ng-container\n            *ngTemplateOutlet=\"dotElm, context: {\n              $implicit: {\n                index : i,\n                currentIndex : currentIndex\n              }\n            }\">\n          </ng-container>\n        </li>\n      </ul>\n      <!-- progress -->\n      <div *ngIf=\"progressElm && autoplay\">\n        <ng-container\n          *ngTemplateOutlet=\"progressElm, context: {\n            $implicit: {\n              progress:progressWidth\n            }\n          }\">\n        </ng-container>\n      </div>\n    </div>\n  `,\n  styles: [`\n    @charset \"UTF-8\";\n    .ngx-hm-carousel-display-npwrap {\n      display: -webkit-box !important;\n      display: -ms-flexbox !important;\n      display: flex !important;\n      -ms-flex-wrap: nowrap !important;\n          flex-wrap: nowrap !important;\n      -webkit-box-orient: horizontal !important;\n      -webkit-box-direction: normal !important;\n          -ms-flex-direction: row !important;\n              flex-direction: row !important;\n      overflow: hidden !important; }\n\n    .carousel {\n      overflow: hidden;\n      position: relative;\n      width: 100%; }\n      .carousel ul.indicators {\n        list-style: none;\n        bottom: 1rem;\n        left: 0;\n        margin: 0;\n        padding: 0;\n        position: absolute;\n        text-align: center;\n        width: 100%; }\n        .carousel ul.indicators li {\n          cursor: pointer;\n          display: inline-block;\n          position: relative;\n          padding: 0.5rem; }\n      .carousel .direction {\n        position: absolute;\n        height: 100%;\n        display: -webkit-box;\n        display: -ms-flexbox;\n        display: flex;\n        -webkit-box-align: center;\n            -ms-flex-align: center;\n                align-items: center;\n        -webkit-box-pack: center;\n            -ms-flex-pack: center;\n                justify-content: center;\n        top: 0; }\n        .carousel .direction.left {\n          left: 0; }\n        .carousel .direction.right {\n          position: absolute;\n          right: 0; }\n\n    .transition {\n      -webkit-transition: all .4s ease-in-out;\n      transition: all .4s ease-in-out; }\n\n    .grab {\n      /* 抓抓抓 */\n      cursor: -webkit-grab;\n      cursor: grab; }\n\n    .grabbing {\n      /* 抓住抓住 */\n      cursor: -webkit-grabbing;\n      cursor: grabbing; }\n\n    .pointer {\n      /* 抓住抓住 */\n      cursor: pointer; }\n  `],\n  encapsulation: ViewEncapsulation.None\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID, ] }, ]},\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'parentChild': [{ type: ViewChild, args: ['parentChild', ] },],\n'btnPrev': [{ type: ViewChild, args: ['prev', ] },],\n'btnNext': [{ type: ViewChild, args: ['next', ] },],\n'items': [{ type: ContentChildren, args: [NgxHmCarouselItemDirective, ] },],\n'contentPrev': [{ type: ContentChild, args: ['carouselPrev', ] },],\n'contentNext': [{ type: ContentChild, args: ['carouselNext', ] },],\n'dotElm': [{ type: ContentChild, args: ['carouselDot', ] },],\n'progressElm': [{ type: ContentChild, args: ['carouselProgress', ] },],\n'infinite': [{ type: Input, args: ['infinite', ] },],\n'mourseEnable': [{ type: Input, args: ['mourse-enable', ] },],\n'speed': [{ type: Input, args: ['autoplay-speed', ] },],\n'delay': [{ type: Input, args: ['between-delay', ] },],\n'direction': [{ type: Input, args: ['autoplay-direction', ] },],\n'showNum': [{ type: Input, args: ['show-num', ] },],\n'scrollNum': [{ type: Input, args: ['scroll-num', ] },],\n'isDragMany': [{ type: Input, args: ['drag-many', ] },],\n'currentIndex': [{ type: Input, args: ['current-index', ] },],\n'autoplay': [{ type: Input, args: ['autoplay', ] },],\n'indexChanged': [{ type: Output, args: ['index-change', ] },],\n'onResize': [{ type: HostListener, args: ['window:resize', ['$event'], ] },],\n};\n}\n\nfunction NgxHmCarouselComponent_tsickle_Closure_declarations() {\n/** @type {?} */\nNgxHmCarouselComponent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgxHmCarouselComponent.ctorParameters;\n/** @type {?} */\nNgxHmCarouselComponent.propDecorators;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.parentChild;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.btnPrev;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.btnNext;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.items;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.contentPrev;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.contentNext;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.dotElm;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.progressElm;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.infinite;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.mourseEnable;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.speed;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.delay;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.direction;\n/** @type {?} */\nNgxHmCarouselComponent.prototype._showNum;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.isAutoNum;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.scrollNum;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.isDragMany;\n/** @type {?} */\nNgxHmCarouselComponent.prototype._viewIndex;\n/** @type {?} */\nNgxHmCarouselComponent.prototype._autoplay;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.indexChanged;\n/** @type {?} */\nNgxHmCarouselComponent.prototype._porgressWidth;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.rootElm;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.containerElm;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.itemsElm;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.hammer;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.elmWidth;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.isInContainer;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.restart;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.stopEvent;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.mostRightIndex;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.doNext;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.sub$;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.prePanMove;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.dots;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.nextListener;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.prevListener;\n/** @type {?} */\nNgxHmCarouselComponent.prototype.platformId;\n/** @type {?} */\nNgxHmCarouselComponent.prototype._renderer;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { NgxHmCarouselComponent } from './ngx-hm-carousel.component';\nimport { NgxHmCarouselItemDirective } from './ngx-hm-carousel-item.directive';\nexport class NgxHmCarouselModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [\n    CommonModule,\n    FormsModule,\n  ],\n  declarations: [\n    NgxHmCarouselComponent,\n    NgxHmCarouselItemDirective,\n  ],\n  exports: [\n    NgxHmCarouselComponent,\n    NgxHmCarouselItemDirective,\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction NgxHmCarouselModule_tsickle_Closure_declarations() {\n/** @type {?} */\nNgxHmCarouselModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgxHmCarouselModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["tryCatchTarget","e","tryCatcher","apply","this","arguments","errorObject_1","errorObject","fn","x","Array","isArray","length","_super","__extends","UnsubscriptionError","errors","call","err","Error","map","i","toString","join","name","stack","message","flattenUnsubscriptionErrors","reduce","errs","concat","UnsubscriptionError_1","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","prototype","hasErrors","index","len","remove","isFunction_1","isFunction","tryCatch_1","tryCatch","isArray_1","sub","isObject_1","isObject","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","value","error","complete","__window","window","__self","self","WorkerGlobalScope","_root","global","root_1","Symbol","root","exports","rxSubscriber","for","$$rxSubscriber","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","Observer_1","SafeSubscriber","rxSubscriber_1","create","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","Subscription_1","Subscriber_2","_parentSubscriber","observerOrNext","context","Object","bind","_context","__tryOrSetError","__tryOrUnsub","_this","wrappedComplete","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","Subscriber_1","subscribe","then","nextOrObserver","getSymbolObservable","$$observable","observable","pipeFromArray","fns","input","prev","noop_1","noop","_i","Observable","_isScalar","_subscribe","lift","operator","source","sink","toSubscriber_1","toSubscriber","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","observable_1","pipe","operations","pipe_1","toPromise","symbolIteratorPonyfill","iterator","Set_1","Set","Map_1","Map","keys","getOwnPropertyNames","key","$$iterator","InnerSubscriber","outerSubscriber","result","InnerSubscriber_1","Observable_1","isArrayLike_1","isArrayLike","isPromise_1","isPromise","setTimeout","iterator_1","item","done","obs","TypeError","msg","AuditSubscriber","durationSelector","hasValue","throttled","duration","innerSubscription","subscribeToResult_1","subscribeToResult","clearThrottle","OuterSubscriber_1","Action","scheduler","work","schedule","state","delay","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","undefined","execute","_execute","errored","errorValue","actions","Action_1","Scheduler","SchedulerAction","now","Date","AsyncScheduler","active","scheduled","action","shift","Scheduler_1","AsyncScheduler_1","AsyncAction_1","val","parseFloat","isNaN","TimerObservable","dueTime","period","isNumeric_1","isNumeric","Number","isScheduler_1","isScheduler","async_1","async","isDate_1","isDate","initialDelay","dispatch","BufferSubscriber","closingNotifier","buffer","bufferCount_2","bufferSize","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","count","Context","BufferTimeSubscriber","bufferTimeSpan","bufferCreationInterval","maxBufferSize","contexts","openContext","timespanOnly","timeSpanOnlyState","closeAction","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","filledBufferContext","onBufferFull","closeContext","prevContext","arg","BufferToggleSubscriber","openings","closingSelector","closeBuffer","openBuffer","trySubscribe","BufferWhenSubscriber","subscribing","closingSubscription","CatchSubscriber","selector","caught","err2","ScalarObservable","EmptyObservable","ArrayObservable","array","of","pop","ScalarObservable_1","EmptyObservable_1","none","CombineLatestSubscriber","project","values","observables","toRespond","unused","oldVal","_tryProject","slice","dispatchNext","dispatchError","PromiseObservable","promise","IteratorObservable_2","IteratorObservable","obj","StringIterator","ArrayIterator","getIterator","hasError","return","str","idx","charAt","arr","o","isFinite","valueAsNumber","sign","Math","floor","abs","maxSafeInteger","toLength","pow","ArrayLikeObservable","arrayLike","Notification","kind","observe","observer","do","accept","toObservable","throw","createNext","undefinedValueNotification","createError","createComplete","completeNotification","observeOn_2","ObserveOnOperator","ObserveOnSubscriber","ObserveOnOperator_1","notification","scheduleMessage","ObserveOnMessage","Notification_1","ObserveOnSubscriber_1","FromObservable","ish","ArrayObservable_1","PromiseObservable_1","IteratorObservable_1","ArrayLikeObservable_1","observeOn_1","mergeMap_2$1","resultSelector","concurrent","POSITIVE_INFINITY","MergeMapOperator","MergeMapSubscriber","MergeMapOperator_1","hasCompleted","_tryNext","_innerSub","_notifyResultSelector","mergeMap_1","mergeMap","identity_1","identity","CountSubscriber","predicate","_tryPredicate","DebounceSubscriber","durationSubscription","emitValue","debounceTime_2","DebounceTimeOperator","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","debouncedNext","dispatchNext$1","DefaultIfEmptySubscriber","defaultValue","isEmpty","DelayMessage","DelaySubscriber","queue","time","delay_1","max","_schedule","scheduleNotification","SubscriptionDelaySubscriber","DelayWhenSubscriber","delayDurationSelector","completed","delayNotifierSubscriptions","removeSubscription","tryComplete","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelayObservable","subscriptionDelay","sourceSubscribed","subscribeToSource","DeMaterializeSubscriber","minimalSetImpl","MinimalSet","_values","has","defineProperty","get","clear","DistinctSubscriber","keySelector","flushes","_useKeySelector","_finalizeNext","DistinctUntilChangedSubscriber","compare","hasKey","y","Boolean","ArgumentOutOfRangeError","ElementAtSubscriber","ArgumentOutOfRangeError_1","EverySubscriber","thisArg","everyValueMatch","SwitchFirstSubscriber","hasSubscription","SwitchFirstMapSubscriber","tryNext","trySelectResult","ExpandSubscriber","subscribeToProjection","FilterSubscriber","FinallySubscriber","callback","FindValueSubscriber","yieldIndex","EmptyError","FirstSubscriber","_emitted","_emit","_tryResultSelector","_emitFinal","EmptyError_1","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","SubjectSubscriber_1","Subject","Subject$$1","thrownError","AnonymousSubject","ObjectUnsubscribedError_1","copy","SubjectSubscription_1","asObservable","Subject_2","MapPolyfill","size","_keys","set","delete","cb","MapPolyfill_1","FastMap","hasOwnProperty","GroupDurationSubscriber","GroupBySubscriber","elementSelector","subjectSelector","groups","attemptedToUnsubscribe","_group","FastMap_1","element","group","Subject_1","groupedObservable","GroupedObservable","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","IgnoreElementsSubscriber","IsEmptySubscriber","LastSubscriber","MapSubscriber","MapToSubscriber","MaterializeSubscriber","ScanSubscriber","accumulator","_seed","hasSeed","seed","TakeLastSubscriber","total","ring","last","mergeAll_1","mergeAll","merge_1","merge","MergeMapToSubscriber","MergeScanSubscriber","acc","refCount_2","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","connect","refCount","sharedConnection","_connection","ConnectableSubscriber","ConnectableObservable","subjectFactory","_isComplete","getSubject","_subject","refCount_1","OnErrorResumeNextSubscriber","nextSources","subscribeToNextSource","PairwiseSubscriber","hasPrev","BehaviorSubject","BehaviorSubject$$1","_value","getValue","AsyncSubject","hasNext","QueueAction","QueueScheduler","QueueAction_1","ReplayEvent","ReplaySubject","windowTime","_events","_bufferSize","_windowTime","_getNow","_trimBufferThenGetEvents","queue_1","eventsCount","spliceCount","RaceSubscriber","hasFirst","RepeatSubscriber","RepeatWhenSubscriber","notifier","sourceIsBeingSubscribedTo","retries","retriesSubscription","subscribeToRetries","notifications","RetrySubscriber","RetryWhenSubscriber","SampleSubscriber","SampleTimeSubscriber","dispatchNotification","SequenceEqualCompareToSubscriber","SequenceEqualSubscriber","compareTo","comparor","_a","_b","_oneComplete","emit","checkValues","a","b","areEqual","nextB","SingleSubscriber","seenValue","applySingleValue","singleValue","SkipSubscriber","SkipLastSubscriber","_skipCount","_count","_ring","skipCount","currentIndex","oldValue","SkipUntilSubscriber","isInnerStopped","SkipWhileSubscriber","skipping","tryCallPredicate","switchMap_2","SwitchMapOperator","SwitchMapSubscriber","_tryNotifyNext","SwitchMapToSubscriber","inner","tryResultSelector","TakeSubscriber","takeUntil_2","TakeUntilOperator","TakeUntilSubscriber","TakeWhileSubscriber","nextOrComplete","predicateResult","tap_2","DoOperator","DoSubscriber","safeSubscriber","defaultThrottleConfig","leading","trailing","throttle","ThrottleOperator","ThrottleSubscriber","_leading","_trailing","_hasTrailingValue","_trailingValue","tryDurationSelector","_sendTrailing","ThrottleTimeSubscriber","dispatchNext$2","TimeInterval","interval","TimeIntervalSubscriber","lastTime","span","TimeoutError","TimeoutSubscriber","absoluteTimeout","waitFor","errorInstance","scheduleTimeout","dispatchTimeout","TimeoutWithSubscriber","withObservable","WindowSubscriber","openWindow","prevWindow","newWindow","WindowCountSubscriber","windowSize","startWindowEvery","windows","c","window_1","CountedSubject","_numberOfNextedValues","WindowTimeSubscriber","windowTimeSpan","windowCreationInterval","maxWindowSize","dispatchWindowClose","dispatchWindowCreation","dispatchWindowTimeSpanOnly","numberOfNextedValues","closeWindow","window_2","timeSpanState","WindowToggleSubscriber","openSubscription","unsubscribeClosingNotification","closingNotification","WithLatestFromSubscriber","found","args","StaticIterator","ZipSubscriber","iterators","StaticArrayIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","nextResult","isComplete","bufferCount","bufferCount_1","debounceTime","debounceTime_1","switchMap","switchMap_1","takeUntil","takeUntil_1","tap","tap_1","NgxHmCarouselItemDirective","throttle_1","clickEvent","EventEmitter","decorators","type","Directive","ctorParameters","propDecorators","Output","onlyOnBrowser","variableId","target","descriptor","originalMethod","_d","isPlatformBrowser","NgxHmCarouselComponent","platformId","_renderer","infinite","mourseEnable","speed","direction","_showNum","isAutoNum","scrollNum","isDragMany","_viewIndex","_autoplay","indexChanged","_porgressWidth","elmWidth","isInContainer","restart","stopEvent","mostRightIndex","getWindowWidthToNum","itemsElm","drawView","progressWidth","sub$","doNext","progressElm","autoplay","onResize","event","setViewWidth","ngAfterContentInit","initVariable","ngAfterViewInit","hammer","bindHammer","bindClick","ngOnDestroy","btnNext","btnPrev","nextListener","prevListener","destroy","rootElm","parentChild","nativeElement","containerElm","children","from","dotElm","dots","startEvent","mourseOver","fromEvent","mourseLeave","runProgress","isInit","addClass","clientWidth","removeClass","setStyle","elm","hm","Hammer","DIRECTION_HORIZONTAL","on","callClick","center","callRestart","handlePan","listen","setIndex","positionX","toIndex","items","playCycle","min","prePanMove","deltaY","outOfBound","deltaX","stop","moveNum","ceil","betweenTime","howTimes","everyIncrease","t","round","windowWidth","innerWidth","Component","template","styles","encapsulation","ViewEncapsulation","None","Inject","PLATFORM_ID","Renderer2","ViewChild","ContentChildren","contentPrev","ContentChild","contentNext","Input","showNum","HostListener","__decorate","NgxHmCarouselModule","NgModule","imports","CommonModule","FormsModule","declarations"],"mappings":"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"}
